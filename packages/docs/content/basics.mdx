---
title: Basic usage
---

This page will walk you through the basics of creating schemas, parsing data, and using inferred types. For complete documentation on Zod's schema API, refer to [Defining schemas](/api).

## Defining a schema

Before you can do anything else, you need to define a schema. For the purposes of this guide, we'll use a simple object schema.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
import * as z from "zod";

const Player = z.interface({ 
  username: z. string(),
  xp: z.number()
});
```
</Tab>
<Tab value="@zod/mini">
```ts
import * as z from "@zod/mini";

const Player = z.interface({ 
  username: z. string(),
  xp: z.number()
});
```
</Tab>
</Tabs>

## Parsing data

Now that we have a schema, we can parse some data with it. 

## `.parse`

`.parse(data: unknown): T`

Given any Zod schema, use `.parse` to validate an input. If it's valid, Zod returns a strongly-typed *deep clone* of the input. 

```ts
Player.parse({ username: "billie", xp: 100 }); 
// => returns { username: "billie", xp: 100 }
```

Otherwise, a `ZodError` instance is thrown with detailed information about the validation issues.

```ts
Player.parse({ username: 42, xp: "100" });

```

## `.parseAsync`

`.parseAsync(data:unknown): Promise<T>`

If you use certain asynchronous APIs (e.g. `async` [refinements](#refine) or [transforms](#transform)), you'll need to use `.parseAsync` instead. 

```ts
const stringSchema = z.string().refine(async (val) => val.length <= 8);

await stringSchema.parseAsync("hello"); // => returns "hello"
await stringSchema.parseAsync("hello world"); // => throws error
```

## `.safeParse`

`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`

If you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.

```ts
stringSchema.safeParse(12);
// => { success: false; error: ZodError }

stringSchema.safeParse("billie");
// => { success: true; data: 'billie' }
```

The result is a _discriminated union_, so you can handle errors very conveniently:

```ts
const result = stringSchema.safeParse("billie");
if (!result.success) {
  // handle error then return
  result.error;
} else {
  // do something
  result.data;
}
```

## `.safeParseAsync`

> Alias: `.spa`

An asynchronous version of `safeParse`.

```ts
await stringSchema.safeParseAsync("billie");
```

For convenience, this has been aliased to `.spa`:

```ts
await stringSchema.spa("billie");
```
