---
title: Handling errors
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

{/* ## `$ZodError` */}

In Zod, validation errors are surfaced as instances of the `z.core.$ZodError` class.

> The `zod` package uses a subclass of this called `ZodError` that implements some additional convenience methods. 

Instances of `$ZodError` contain an `.issues` property containing a human-readable `message` and additional structured information about each encountered validation issue. 


<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
import * as z from "zod";

const result = z.string().safeParse(12); // { success: false, error: ZodError }
result.error.issues;
// [
//   {
//     expected: 'string',
//     code: 'invalid_type',
//     path: [],
//     message: 'Invalid input: expected string, received number'
//   }
// ]
```
</Tab>
<Tab value="@zod/mini">
```ts
import * as z from "@zod/min";

const result = z.string().safeParse(12); // { success: false, error: z.core.$ZodError }
result.error.issues;
// [
//   {
//     expected: 'string',
//     code: 'invalid_type',
//     path: [],
//     message: 'Invalid input'
//   }
// ]
```

</Tab>
</Tabs>

## Customization

Every issue inside a `$ZodError` contains a `message` property with a human-readable error message. This message can be customized in a number of ways.

{/* ## Error reporting in Zod

Both Zod and `@zod/mini` depend on an common internal library called `@zod/core`. This core library exports an error class `$ZodError`, which serves as the basis for all error reporting in Zod. You can access this class using the `z.core` namespace.

```ts
import * as z from "zod";

z.core.$ZodError;
```

The `zod` library exports a subclass of `$ZodError` called simply `ZodError`. This subclass adds some convenience methods to the base class. */}


### The `error` param

Virtually every Zod API accepts an optional parameters object. The `error` param is used to customize the error messages produced by a particular schema.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
z.string({ error: "Bad!"}).parse(12);

// throws ZodError {
//   issues: [
//     {
//       expected: 'string',
//       code: 'invalid_type',
//       path: [],
//       message: 'Bad!'   <-- ðŸ‘€ custom error message 
//     }
//   ]
// }
```
</Tab>
<Tab value="@zod/mini">
```ts
z.string({ error: "Bad string"}).parse(12);

// throws $ZodError {
//   issues: [
//     {
//       expected: 'string',
//       code: 'invalid_type',
//       path: [],
//       message: 'Bad string'
//     }
//   ]
// }
```

</Tab>
</Tabs>

Nearly all functions and methods support `error`.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
z.string({ error: "Bad!" });
z.string().min(5, { error: "Too short!" });
z.uuid({ error: "Bad UUID!" });
z.iso.date({ error: "Bad date!" });
z.array(z.string(), { error: "Bad array!" });
z.array(z.string()).min(5, { error: "Too few items!" });
z.set(z.string(), { error: "Bad set!" });
z.array(z.string(), { error: "Bad array!" });
z.set(z.string(), { error: "Bad set!" });
z.array(z.string(), { error: "Bad array!" });
```
</Tab>
<Tab value="@zod/mini">
```ts
z.string({ error: "Bad!" });
z.string().check(z.minLength(5, { error: "Too short!" }));
z.uuid({ error: "Bad UUID!" });
z.iso.date({ error: "Bad date!" });
z.array(z.string(), { error: "Bad array!" });
z.array(z.string()).check(z.minLength(5, { error: "Too few items!" }));
z.set(z.string(), { error: "Bad set!" });
z.array(z.string(), { error: "Bad array!" });
z.set(z.string(), { error: "Bad set!" });
z.array(z.string(), { error: "Bad array!" });
```

</Tab>
</Tabs>

The `error` param optionally accepts a function, also known as an **error map**. This function will be called at parse time.

```ts
z.string({ error: ()=>`[${Date.now()}]: Validation failure.` });
```

<Callout>
**Note** â€” In Zod v3, there were separate params for `message` (a string) and `errorMap` (a function). These have been unified in Zod 4 as `error`.
</Callout>


The `error` function received a context object you can use to customize the error message based on the `input` or other validation information.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
z.string({
  error: (iss) => iss.input===undefined ? "Field is required." : "Invalid input."
});
```
</Tab>
<Tab value="@zod/mini">
```ts
z.string({
  error: (iss) => iss.input===undefined ? "Field is required." : "Invalid input."
});
```
</Tab>
</Tabs>

For advanced cases, the `iss` object provides additional information you can use to customize the error.


<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
z.string({
  error: (iss) => {
    iss.code; // the issue code
    iss.input; // the input data
    iss.inst; // the schema/check that originated this issue
    iss.path; // the path of the error
  },
});
```
</Tab>
<Tab value="@zod/mini">
```ts
z.string({
  error: (iss) => {
    iss.inst;
    iss.code; // the issue code
    iss.input; // the input data
    iss.inst; // the schema/check that originated this issue
    iss.path; // the path of the error
  },
});
```
</Tab>
</Tabs>

Depending on the API you are using, there may be additional properties available. Use TypeScript's autocomplete to explore the available properties.

```ts
z.string().min(5, {
  error: (iss) => {
    // ...the same as above
    iss.minimum; // the minimum value
    iss.inclusive; // whether the minimum is inclusive
    return `Password must have ${iss.minimum} characters or more`;
  },
});
```

### Per-parse error customization

To customize errors on a *per-parse* basis, pass an error map into the parse method:

```ts
const schema = z.string()

schema.parse(12, {
  error: iss => "per-parse custom error"
};
```

This has *lower precedence* than any schema-level custom messages.

```ts
const schema = z.string({ error: "highest priority" });
const result = schema.safeParse(12, {
  error: (iss) => "lower priority",
})

result.error.issues;
// [{ message: "highest priority", ... }]
```

The `iss` object is a [discriminated union](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions) of all possible issue types. Use the `code` property to discriminate between them. 

> For a breakdown of all Zod issue codes, see the [`@zod/core`](/packages/core#issue-types) documentation.

```ts
const result = schema.safeParse(12, {
  error: (iss) => {
    if (iss.code === "invalid_type") {
      return `invalid type, expected ${iss.expected}`;
    }
    if (iss.code === "too_small") {
      return `minimum is ${iss.minimum}`;
    }
    // ...
  }
})
```


### Global error customization

To specify a global error map, use `z.config()` to set Zod's `customError` configuration setting:

```ts
z.config({
  customError: (iss) => {
    return "globally modified error";
  },
});
```

Global error messages have *lower precedence* than schema-level or per-parse error messages. 

The `iss` object is a [discriminated union](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions) of all possible issue types. Use the `code` property to discriminate between them.

> For a breakdown of all Zod issue codes, see the [`@zod/core`](/core#issue-types) documentation.

```ts
const result = schema.safeParse(12, {
  error: (iss) => {
    if (iss.code === "invalid_type") {
      return `invalid type, expected ${iss.expected}`;
    }
    if (iss.code === "too_small") {
      return `minimum is ${iss.minimum}`;
    }
    // ...
  }
})
```

### Internationalization

To support internationalization of error message, Zod provides several built-in **locales**. These are exported from the `@zod/core` package.

> **Note** â€” The `zod` library automatically loads the `en` locale automatically. The `@zod/mini`package does not load any locale; instead all error messages default to `Invalid input`.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
import * as z from "zod";
import en from "@zod/core/locales/en"

z.config(en());
```
</Tab>
<Tab value="@zod/mini">
```ts
import * as z from "@zod/mini";
import en from "@zod/core/locales/en"

z.config(en());
```
</Tab>
</Tabs>

For convenience, you can also references these from the `z.core` namespace exports from `zod`/`@zod/mini`.

<Tabs groupId="lib" items={["zod", "@zod/mini"]}>
<Tab value="zod">
```ts
import * as z from "zod";

z.config(z.core.locales.en());
```
</Tab>
<Tab value="@zod/mini">
```ts
import * as z from "@zod/mini";

z.config(z.core.locales.en());
```
</Tab>
</Tabs>



### Error handling

Zod provides a subclass of Error called `ZodError`. ZodErrors contain an `issues` array containing detailed information about the validation problems.

```ts
const result = z
  .object({
    name: z.string(),
  })
  .safeParse({ name: 12 });

if (!result.success) {
  result.error.issues;
  /* [
      {
        "code": "invalid_type",
        "expected": "string",
        "received": "number",
        "path": [ "name" ],
        "message": "Expected string, received number"
      }
  ] */
}
```

> For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)

Zod's error reporting emphasizes _completeness_ and _correctness_. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like [`zod-validation-error`](https://github.com/causaly/zod-validation-error)

## Formatting

Zod emphasizes _completeness_ and _correctness_ in its error reporting. In many cases, it's helpful to convert the `$ZodError` to a more useful format. Zod provides some utilities for this.

Consider this simple object schema.

```ts
const schema = z.object({
  username: z.string(),
  favoriteNumbers: z.array(z.number()),
});
```

Attempting to parse this invalid data results in an error containing two issues. 

```ts
const result = schema.safeParse({
  username: 1234,
  favoriteNumbers: [1234, "4567"],
});

result.error!.issues;
[
  {
    expected: 'string',
    code: 'invalid_type',
    path: [ 'username' ],
    message: 'Invalid input: expected string'
  },
  {
    expected: 'number',
    code: 'invalid_type',
    path: [ 'favoriteNumbers', 1 ],
    message: 'Invalid input: expected number'
  }
];
```

{/* ### `z.formatError()`

To convert the error into a nested object:

```ts
const formatted = z.formatError(result.error);

// returns:
{
  "_errors": [],
  "string": {
    "_errors": [
      "Invalid input: expected string"
    ]
  },
  "numbers": {
    "1": {
      "_errors": [
        "Invalid input: expected number"
      ]
    },
    "_errors": []
  }
}
```

The result is a nested structure that mirrors the schema itself. You can easily access the errors that occured at a particular path.

```ts
formatted?.string?._errors;
// => ["Invalid input: expected string"]

formatted?.numbers?.[1]?._errors;
// => ["Invalid input: expected number"]
```

> Be sure to use optional chaining (`?.`) to avoid errors when accessing nested properties.

### `z.error.shallowTree()`

While `z.formatError()` is useful for traversing a potentially complex nested structure, the majority of schemas are *flat*â€”just one level deep. In this case, use `z.flattenError()` to retrieve a clean, shallow error object.

```ts
const flattened = z.flattenError(result.error);
// { errors: string[], properties: { [key: string]: string[] } }

{
  errors: [],
  properties: {
    string: [ 'Invalid input: expected string' ],
    numbers: [ 'Invalid input: expected number' ]
  }
}
```

The `formErrors` array contains any top-level errors (where `path` is `[]`). The `fieldErrors` object provides an array of errors for each field in the schema.

```ts
flattened.fieldErrors.string; // => [ 'Invalid input: expected string' ]
flattened.fieldErrors.numbers; // => [ 'Invalid input: expected number' ]
```

> **Note** â€” If you have issues with a `path` longer than one level, this function throws away some error information.  */}


### `z.treeifyError()`

To convert ("treeify") this error into a nested object, use `z.treeifyError()`.


```ts
const tree = z.treeifyError(result.error);

// =>
{
  errors: [],
  fields: {
    username: { errors: [ 'Invalid input: expected string' ] },
    favoriteNumbers: {
      errors: [],
      items: [
        undefined,
        { errors: [ 'Invalid input: expected number' ] }
      ]
    }
  }
}
```

The result is a nested structure that mirrors the schema itself. You can easily access the errors that occured at a particular path. The `errors` field contains the error messages at a given path, and the special properties `fields` and `items` let you traverse deeper into the tree.

```ts
tree.fields?.username?.errors;
// => ["Invalid input: expected string"]

tree.fields?.favoriteNumbers?.items?.[1]?.errors;
// => ["Invalid input: expected number"];
```

> Be sure to use optional chaining (`?.`) to avoid errors when accessing nested properties.

### `z.prettyError()`

The `z.prettyError()` provides a human-readable string representation of the error.

```ts
const stringified = z.prettyError(result.error);
```

This returns the following string:

```
username
  âœ– Invalid input: expected string, received number
favoriteNumbers[1]
  âœ– Invalid input: expected number, received string
```



