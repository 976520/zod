<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zod Documentation</title>
    <meta property="og:title" content="Zod Documentation">
    <meta property="og:description" content="TypeScript-first schema validation with static type inference">
    <meta property="og:image" content="og-image.png">
    <link rel="stylesheet" href="styles.css">
    <link href="https://unpkg.com/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-slate-100 antialiased">
    <div class="flex">
        <main class="w-full max-w-4xl px-6 py-12 mx-auto prose prose-invert prose-slate prose-headings:scroll-mt-20 prose-h1:text-3xl prose-h2:text-2xl prose-h3:text-xl prose-pre:bg-transparent prose-pre:p-0 prose-pre:m-0 prose-a:text-blue-400 prose-a:no-underline hover:prose-a:text-blue-300 prose-img:rounded-lg prose-img:shadow-lg">
            <p class="mb-4"><img src="logo.svg" width="200px" align="center" alt="Zod logo" /><h1 align="center">Zod</h1><p align="center"> ✨ <a href="https://zod.dev">https://zod.dev</a> ✨ <br/> TypeScript-first schema validation with static type inference </p><br/></p><p class="mb-4"><a href="https://github.com/colinhacks/zod/actions?query=branch%3Amaster"><img src="https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&branch=master" alt="Zod CI status" /></a><a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell"></a><a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License"></a><a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm"></a><a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars"></a><a href="https://discord.gg/KaSRdyX2vc" rel="nofollow"><img src="https://img.shields.io/discord/893487829802418277?label=Discord&logo=discord&logoColor=white" alt="discord server"></a></p><p class="mb-4"><div align="center"><a href="https://zod.dev">Documentation</a><span> • </span><a href="https://discord.gg/RcG33DQJdf">Discord</a><span> • </span><a href="https://www.npmjs.com/package/zod">npm</a><span> • </span><a href="https://deno.land/x/zod">deno</a><span> • </span><a href="https://github.com/colinhacks/zod/issues/new">Issues</a><span> • </span><a href="https://twitter.com/colinhacks">@colinhacks</a><span> • </span><a href="https://trpc.io">tRPC</a><br /></div></p><p class="mb-4"><br/><br/></p><blockquote><p class="mb-4">Zod 3.23 is out! View the <a href="#release-notes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">release notes</a>.</p></blockquote><blockquote><p class="mb-4">These docs have been translated into <a href="#chinese" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Chinese</a>.</p></blockquote><h1 id="table-of-contents" class="heading-1" data-heading="true">Table of contents</h1><p class="mb-4"><!-- The full documentation is available both on the <a href="#official-documentation-site" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">official documentation site</a> (recommended) and in <code>README.md</code>.</p><h1 id="go-to-zod-js-org" class="heading-1" data-heading="true">Go to <a href="#zod-js-org" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">zod.js.org</a> >> --></h1><ul><li><a href="#table-of-contents" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Table of contents</a></li><li><a href="#introduction" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Introduction</a><ul><li><a href="#sponsors" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Sponsors</a><ul><li><a href="#gold" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Gold</a></li><li><a href="#silver" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Silver</a></li><li><a href="#bronze" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Bronze</a></li><li><a href="#copper" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Copper</a></li></ul></li><li><a href="#ecosystem" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Ecosystem</a><ul><li><a href="#resources" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Resources</a></li><li><a href="#api-libraries" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">API libraries</a></li><li><a href="#form-integrations" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Form integrations</a></li><li><a href="#zod-to-x" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Zod to X</a></li><li><a href="#x-to-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">X to Zod</a></li><li><a href="#mocking" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Mocking</a></li><li><a href="#powered-by-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Powered by Zod</a></li><li><a href="#utilities-for-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Utilities for Zod</a></li></ul></li></ul></li><li><a href="#installation" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Installation</a><ul><li><a href="#requirements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Requirements</a></li><li><a href="#from-npm-node-bun" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">From <code>npm</code> (Node/Bun)</a></li><li><a href="#from-deno-land-x-deno" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">From <code>deno.land/x</code> (Deno)</a></li></ul></li><li><a href="#basic-usage" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Basic usage</a></li><li><a href="#primitives" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Primitives</a></li><li><a href="#coercion-for-primitives" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Coercion for primitives</a></li><li><a href="#literals" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Literals</a></li><li><a href="#strings" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Strings</a><ul><li><a href="#datetimes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Datetimes</a></li><li><a href="#dates" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Dates</a></li><li><a href="#times" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Times</a></li><li><a href="#ip-addresses" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">IP addresses</a></li><li><a href="#json" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">JSON</a></li></ul></li><li><a href="#numbers" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Numbers</a></li><li><a href="#bigints" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">BigInts</a></li><li><a href="#nans" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">NaNs</a></li><li><a href="#booleans" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Booleans</a></li><li><a href="#dates" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Dates</a></li><li><a href="#zod-enums" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Zod enums</a></li><li><a href="#native-enums" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Native enums</a></li><li><a href="#optionals" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Optionals</a></li><li><a href="#nullables" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Nullables</a></li><li><a href="#objects" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Objects</a><ul><li><a href="#shape" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.shape</code></a></li><li><a href="#keyof" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.keyof</code></a></li><li><a href="#extend" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.extend</code></a></li><li><a href="#merge" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.merge</code></a></li><li><a href="#pick-omit" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.pick/.omit</code></a></li><li><a href="#partial" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.partial</code></a></li><li><a href="#deeppartial" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.deepPartial</code></a></li><li><a href="#required" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.required</code></a></li><li><a href="#passthrough" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.passthrough</code></a></li><li><a href="#strict" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.strict</code></a></li><li><a href="#strip" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.strip</code></a></li><li><a href="#catchall" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.catchall</code></a></li></ul></li><li><a href="#arrays" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Arrays</a><ul><li><a href="#element" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.element</code></a></li><li><a href="#nonempty" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.nonempty</code></a></li><li><a href="#min-max-length" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.min/.max/.length</code></a></li><li><a href="#unique" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.unique</code></a></li></ul></li><li><a href="#tuples" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Tuples</a></li><li><a href="#unions" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Unions</a></li><li><a href="#discriminated-unions" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Discriminated unions</a></li><li><a href="#records" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Records</a><ul><li><a href="#record-key-type" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Record key type</a></li></ul></li><li><a href="#maps" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Maps</a></li><li><a href="#sets" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Sets</a></li><li><a href="#intersections" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Intersections</a></li><li><a href="#recursive-types" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Recursive types</a><ul><li><a href="#zodtype-with-zodeffects" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">ZodType with ZodEffects</a></li><li><a href="#json-type" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">JSON type</a></li><li><a href="#cyclical-objects" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Cyclical objects</a></li></ul></li><li><a href="#promises" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Promises</a></li><li><a href="#instanceof" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Instanceof</a></li><li><a href="#functions" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Functions</a></li><li><a href="#template-literals" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Template Literals</a></li><li><a href="#preprocess" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Preprocess</a></li><li><a href="#custom-schemas" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Custom schemas</a></li><li><a href="#schema-methods" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Schema methods</a><ul><li><a href="#parse" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.parse</code></a></li><li><a href="#parseasync" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.parseAsync</code></a></li><li><a href="#safeparse" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.safeParse</code></a></li><li><a href="#safeparseasync" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.safeParseAsync</code></a></li><li><a href="#refine" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.refine</code></a><ul><li><a href="#arguments" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Arguments</a></li><li><a href="#customize-error-path" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Customize error path</a></li><li><a href="#asynchronous-refinements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Asynchronous refinements</a></li><li><a href="#relationship-to-transforms" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Relationship to transforms</a></li></ul></li><li><a href="#superrefine" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.superRefine</code></a><ul><li><a href="#abort-early" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Abort early</a></li><li><a href="#type-refinements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Type refinements</a></li></ul></li><li><a href="#transform" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.transform</code></a><ul><li><a href="#chaining-order" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Chaining order</a></li><li><a href="#validating-during-transform" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Validating during transform</a></li><li><a href="#relationship-to-refinements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Relationship to refinements</a></li><li><a href="#async-transforms" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Async transforms</a></li></ul></li><li><a href="#default" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.default</code></a></li><li><a href="#describe" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.describe</code></a></li><li><a href="#catch" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.catch</code></a></li><li><a href="#optional" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.optional</code></a></li><li><a href="#nullable" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.nullable</code></a></li><li><a href="#nullish" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.nullish</code></a></li><li><a href="#array" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.array</code></a></li><li><a href="#promise" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.promise</code></a></li><li><a href="#or" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.or</code></a></li><li><a href="#and" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.and</code></a></li><li><a href="#brand" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.brand</code></a></li><li><a href="#readonly" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.readonly</code></a></li><li><a href="#pipe" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.pipe</code></a><ul><li><a href="#you-can-use-pipe-to-fix-common-issues-with-z-coerce" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">You can use <code>.pipe()</code> to fix common issues with <code>z.coerce</code>.</a></li></ul></li></ul></li><li><a href="#guides-and-concepts" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Guides and concepts</a><ul><li><a href="#type-inference" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Type inference</a></li><li><a href="#writing-generic-functions" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Writing generic functions</a><ul><li><a href="#constraining-allowable-inputs" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Constraining allowable inputs</a></li></ul></li><li><a href="#error-handling" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Error handling</a></li><li><a href="#error-formatting" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Error formatting</a></li></ul></li><li><a href="#comparison" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Comparison</a><ul><li><a href="#joi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Joi</a></li><li><a href="#yup" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Yup</a></li><li><a href="#io-ts" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">io-ts</a></li><li><a href="#runtypes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Runtypes</a></li><li><a href="#ow" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Ow</a></li></ul></li><li><a href="#changelog" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Changelog</a></li></ul><h1 id="introduction" class="heading-1" data-heading="true">Introduction</h1><p class="mb-4">Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple <code>string</code> to a complex nested object.</p><p class="mb-4">Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator <em>once</em> and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.</p><p class="mb-4">Some other great aspects:</p><ul><li>Zero dependencies</li><li>Works in Node.js and all modern browsers</li><li>Tiny: 8kb minified + zipped</li><li>Immutable: methods (e.g. <code>.optional()</code>) return a new instance</li><li>Concise, chainable interface</li><li>Functional approach: <a href="#parse-don-t-validate" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">parse, don't validate</a></li><li>Works with plain JavaScript too! You don't need to use TypeScript.</li></ul><h1 id="sponsors" class="heading-1" data-heading="true">Sponsors</h1><p class="mb-4">Sponsorship at any level is appreciated and encouraged. For individual developers, consider the <a href="#cup-of-coffee-tier" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Cup of Coffee tier</a>. If you built a paid product using Zod, consider one of the <a href="#podium-tiers" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">podium tiers</a>.</p><h1 id="gold" class="heading-1" data-heading="true">Gold</h1><blockquote><p class="mb-4">This tier was just added. <a href="#be-the-first-gold-sponsor" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Be the first Gold Sponsor!</a></p></blockquote><p class="mb-4"><!-- <table><tr><td align="center"><a href="https://www.example.com" target="_blank"><img src="https://example.com/image.png" height="100px;" alt="XXX" /></a><br /><b>XXX</b><br /><a href="https://www.example.com" target="_blank">example.com</a></td></tr></table> --></p><h1 id="silver" class="heading-1" data-heading="true">Silver</h1><p class="mb-4"><table><tr><td align="center"><img src="https://avatars.githubusercontent.com/u/80861386?s=200&v=4" height="45px;" alt="Cerbos" /><br /><a href="https://cerbos.dev/" target="_blank">Cerbos</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/301879?s=200&v=4" height="45px;" alt="Scalar.com logo" /><br /><a href="https://scalar.com/" target="_blank">Scalar</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/91446104?s=200&v=4" height="45px;" alt="Speakeasy API" /><br /><a href="https://speakeasyapi.dev/" target="_blank">Speakeasy</a></td><td align="center"><img src="https://avatars0.githubusercontent.com/u/15068039?s=200&v=4" height="45px;" alt="Deletype logo" /><br /><a href="https://deletype.com" target="_blank">Deletype</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/95297378?s=200&v=4" height="45px;" alt="Trigger.dev logo" /><br /><a href="https://trigger.dev" target="_blank">Trigger.dev</a></td></tr><tr><td align="center"><img src="https://avatars.githubusercontent.com/u/125754?s=200&v=4" height="45px;" alt="Transloadit logo" /><br /><a href="https://transloadit.com/?utm_source=zod&utm_medium=refe rral&utm_campaign=sponsorship&utm_content=github" target="_blank">Transloadit</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/107880645?s=200&v=4" height="45px;" alt="Infisical logo" /><br /><a href="https://infisical.com" target="_blank">Infisical</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/91036480?s=200&v=4" height="45px;" alt="Whop logo" /><br /><a href="https://whop.com/" target="_blank">Whop</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/36402888?s=200&v=4" height="45px;" alt="CryptoJobsList logo" /><br /><a href="https://cryptojobslist.com/" target="_blank">CryptoJobsList</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/70170949?s=200&v=4" height="45px;" alt="Plain logo" /><br /><a href="https://plain.com/" target="_blank">Plain.</a></td></tr><tr><td align="center"><img src="https://avatars.githubusercontent.com/u/78935958?s=200&v=4" height="45px;" alt="Inngest logo" /><br /><a href="https://inngest.com/" target="_blank">Inngest</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/13880908?s=200&v=4" height="45px;" alt="Storyblok CMS" /><br /><a href="https://storyblok.com/" target="_blank">Storyblok</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/16199997?s=200&v=4" height="45px;" alt="Mux logo" /><br /><a href="https://mux.link/zod" target="_blank">Mux</a></td><td align="center"><img src="https://avatars.githubusercontent.com/u/180984?v=4" height="45px;" alt="@emreb" /><br /><a href="https://github.com/emreb" target="_blank"><code>@emreb</code></a></td></tr></table></p><h1 id="bronze" class="heading-1" data-heading="true">Bronze</h1><p class="mb-4"><table><tr><td><a href="https://www.numeric.io">Numeric</a></td><td><a href="https://marcatopartners.com/">Marcato Partners</a></td><td><a href="https://interval.com">Interval</a></td><td><a href="https://seasoned.cc">Seasoned Software</a></td></tr><tr><td><a href="https://www.bamboocreative.nz/">Bamboo Creative</a></td></tr></table></p><h1 id="copper" class="heading-1" data-heading="true">Copper</h1><p class="mb-4"><table><tr><td>Brandon Bayer</td><td>Jiří Brabec</td><td>Alex Johansson</td><td>Fungible Systems</td></tr><tr><td>Adaptable</td><td>Avana Wallet</td><td>Jason Lengstorf</td><td>Global Illumination, Inc.</td></tr><tr><td>MasterBorn</td><td>Ryan Palmer</td><td>Michael Sweeney</td><td>Nextbase</td></tr><tr><td>Remotion</td><td>Connor Sinnott</td><td>Mohammad-Ali A'râbi</td><td>Supatool</td></tr></table></p><h1 id="ecosystem" class="heading-1" data-heading="true">Ecosystem</h1><p class="mb-4">There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it <a href="#on-twitter" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">on Twitter</a> or <a href="#start-a-discussion" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">start a Discussion</a>. I'll add it below and tweet it out.</p><h1 id="resources" class="heading-1" data-heading="true">Resources</h1><ul><li><a href="#total-typescript-zod-tutorial" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Total TypeScript Zod Tutorial</a> by <a href="#mattpocockuk" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">@mattpocockuk</a></li><li><a href="#fixing-typescript-s-blindspot-runtime-typechecking" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Fixing TypeScript's Blindspot: Runtime Typechecking</a> by <a href="#jherr" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">@jherr</a></li></ul><h1 id="api-libraries" class="heading-1" data-heading="true">API libraries</h1><ul><li><a href="#trpc" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>tRPC</code></a>: Build end-to-end typesafe APIs without GraphQL.</li><li><a href="#anatine-zod-nestjs" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@anatine/zod-nestjs</code></a>: Helper methods for using Zod in a NestJS project.</li><li><a href="#zod-endpoints" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-endpoints</code></a>: Contract-first strictly typed endpoints with Zod. OpenAPI compatible.</li><li><a href="#zhttp" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zhttp</code></a>: An OpenAPI compatible, strictly typed http library with Zod input and response validation.</li><li><a href="#domain-functions" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>domain-functions</code></a>: Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.</li><li><a href="#zodios-core" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@zodios/core</code></a>: A typescript API client with runtime and compile time validation backed by axios and zod.</li><li><a href="#express-zod-api" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>express-zod-api</code></a>: Build Express-based APIs with I/O schema validation and custom middlewares.</li><li><a href="#tapiduck" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>tapiduck</code></a>: End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.</li><li><a href="#koa-zod-router" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>koa-zod-router</code></a>: Create typesafe routes in Koa with I/O validation using Zod.</li></ul><h1 id="form-integrations" class="heading-1" data-heading="true">Form integrations</h1><ul><li><a href="#react-hook-form" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>react-hook-form</code></a>: A first-party Zod resolver for React Hook Form.</li><li><a href="#zod-validation-error" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-validation-error</code></a>: Generate user-friendly error messages from <code>ZodError</code>s.</li><li><a href="#zod-formik-adapter" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-formik-adapter</code></a>: A community-maintained Formik adapter for Zod.</li><li><a href="#react-zorm" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>react-zorm</code></a>: Standalone <code>&lt;form&gt;</code> generation and validation for React using Zod.</li><li><a href="#zodix" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zodix</code></a>: Zod utilities for FormData and URLSearchParams in Remix loaders and actions.</li><li><a href="#conform" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>conform</code></a>: A typesafe form validation library for progressive enhancement of HTML forms. Works with Remix and Next.js.</li><li><a href="#remix-params-helper" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>remix-params-helper</code></a>: Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.</li><li><a href="#formik-validator-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>formik-validator-zod</code></a>: Formik-compliant validator library that simplifies using Zod with Formik.</li><li><a href="#zod-i18n-map" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-i18n-map</code></a>: Useful for translating Zod error messages.</li><li><a href="#modular-forms-solid" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@modular-forms/solid</code></a>: Modular form library for SolidJS that supports Zod for validation.</li><li><a href="#houseform" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>houseform</code></a>: A React form library that uses Zod for validation.</li><li><a href="#sveltekit-superforms" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>sveltekit-superforms</code></a>: Supercharged form library for SvelteKit with Zod validation.</li><li><a href="#mobx-zod-form" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>mobx-zod-form</code></a>: Data-first form builder based on MobX & Zod.</li><li><a href="#vee-validate-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@vee-validate/zod</code></a>: Form library for Vue.js with Zod schema validation.</li></ul><h1 id="zod-to-x" class="heading-1" data-heading="true">Zod to X</h1><ul><li><a href="#zod-to-ts" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-to-ts</code></a>: Generate TypeScript definitions from Zod schemas.</li><li><a href="#zod-to-json-schema" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-to-json-schema</code></a>: Convert your Zod schemas into <a href="#json-schemas" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">JSON Schemas</a>.</li><li><a href="#anatine-zod-openapi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@anatine/zod-openapi</code></a>: Converts a Zod schema to an OpenAPI v3.x <code>SchemaObject</code>.</li><li><a href="#zod-fast-check" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-fast-check</code></a>: Generate <code>fast-check</code> arbitraries from Zod schemas.</li><li><a href="#zod-dto" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-dto</code></a>: Generate Nest.js DTOs from a Zod schema.</li><li><a href="#fastify-type-provider-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>fastify-type-provider-zod</code></a>: Create Fastify type providers from Zod schemas.</li><li><a href="#zod-to-openapi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-to-openapi</code></a>: Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints & parameters.</li><li><a href="#nestjs-graphql-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>nestjs-graphql-zod</code></a>: Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.</li><li><a href="#zod-openapi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-openapi</code></a>: Create full OpenAPI v3.x documentation from Zod schemas.</li><li><a href="#fastify-zod-openapi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>fastify-zod-openapi</code></a>: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.</li><li><a href="#typeschema" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>typeschema</code></a>: Universal adapter for schema validation.</li></ul><h1 id="x-to-zod" class="heading-1" data-heading="true">X to Zod</h1><ul><li><a href="#ts-to-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>ts-to-zod</code></a>: Convert TypeScript definitions into Zod schemas.</li><li><a href="#runtyping-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@runtyping/zod</code></a>: Generate Zod from static types & JSON schema.</li><li><a href="#json-schema-to-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>json-schema-to-zod</code></a>: Convert your <a href="#json-schemas" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">JSON Schemas</a> into Zod schemas. <a href="#live-demo" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Live demo</a>.</li><li><a href="#json-to-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>json-to-zod</code></a>: Convert JSON objects into Zod schemas. <a href="#live-demo" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Live demo</a>.</li><li><a href="#graphql-codegen-typescript-validation-schema" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>graphql-codegen-typescript-validation-schema</code></a>: GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.</li><li><a href="#zod-prisma" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-prisma</code></a>: Generate Zod schemas from your Prisma schema.</li><li><a href="#supervillain" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>Supervillain</code></a>: Generate Zod schemas from your Go structs.</li><li><a href="#prisma-zod-generator" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>prisma-zod-generator</code></a>: Emit Zod schemas from your Prisma schema.</li><li><a href="#prisma-trpc-generator" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>prisma-trpc-generator</code></a>: Emit fully implemented tRPC routers and their validation schemas using Zod.</li><li><a href="#zod-prisma-types" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-prisma-types</code></a> Create Zod types from your Prisma models.</li><li><a href="#quicktype" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>quicktype</code></a>: Convert JSON objects and JSON schemas into Zod schemas.</li><li><a href="#sanity-typed-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@sanity-typed/zod</code></a>: Generate Zod Schemas from <a href="#sanity-schemas" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Sanity Schemas</a>.</li><li><a href="#java-to-zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>java-to-zod</code></a>: Convert POJOs to Zod schemas</li><li><a href="#orval" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>Orval</code></a>: Generate Zod schemas from OpenAPI schemas</li></ul><h1 id="mocking" class="heading-1" data-heading="true">Mocking</h1><ul><li><a href="#anatine-zod-mock" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>@anatine/zod-mock</code></a>: Generate mock data from a Zod schema. Powered by <a href="#faker-js" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">faker.js</a>.</li><li><a href="#zod-mocking" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-mocking</code></a>: Generate mock data from your Zod schemas.</li><li><a href="#zod-fixture" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-fixture</code></a>: Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.</li><li><a href="#zocker" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zocker</code></a>: Generate plausible mock-data from your schemas.</li><li><a href="#zodock" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zodock</code></a> Generate mock data based on Zod schemas.</li></ul><h1 id="powered-by-zod" class="heading-1" data-heading="true">Powered by Zod</h1><ul><li><a href="#freerstore" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>freerstore</code></a>: Firestore cost optimizer.</li><li><a href="#slonik" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>slonik</code></a>: Node.js Postgres client with strong Zod integration.</li><li><a href="#soly" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>soly</code></a>: Create CLI applications with zod.</li><li><a href="#pastel" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>pastel</code></a>: Create CLI applications with react, zod, and ink.</li><li><a href="#zod-xlsx" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-xlsx</code></a>: A xlsx based resource validator using Zod schemas.</li><li><a href="#znv" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>znv</code></a>: Type-safe environment parsing and validation for Node.js with Zod schemas.</li><li><a href="#zod-config" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-config</code></a>: Load configurations across multiple sources with flexible adapters, ensuring type safety with Zod.</li></ul><h1 id="utilities-for-zod" class="heading-1" data-heading="true">Utilities for Zod</h1><ul><li><a href="#zod-utilz" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod_utilz</code></a>: Framework agnostic utilities for Zod.</li><li><a href="#zod-playground" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-playground</code></a>: A tool for learning and testing Zod schema validation functionalities. <a href="#link" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Link</a>.</li><li><a href="#zod-sandbox" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-sandbox</code></a>: Controlled environment for testing zod schemas. <a href="#live-demo" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Live demo</a>.</li><li><a href="#zod-dev" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-dev</code></a>: Conditionally disables Zod runtime parsing in production.</li><li><a href="#zod-accelerator" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-accelerator</code></a>: Accelerates Zod's throughput up to ~100x.</li></ul><h1 id="installation" class="heading-1" data-heading="true">Installation</h1><h1 id="requirements" class="heading-1" data-heading="true">Requirements</h1><ul><li><p class="mb-4">TypeScript 4.5+!</p></li><li><p class="mb-4">You must enable <code>strict</code> mode in your <code>tsconfig.json</code>. This is a best practice for all TypeScript projects.</p><pre tabindex="0"><code class="language-ts" data-prism="true">// tsconfig.json { // ... &quot;compilerOptions&quot;: { // ... &quot;strict&quot;: true } } </code></pre></li></ul><h1 id="from-npm-node-bun" class="heading-1" data-heading="true">From <code>npm</code> (Node/Bun)</h1><pre tabindex="0"><code class="language-sh" data-prism="true">npm install zod # npm yarn add zod # yarn bun add zod # bun pnpm add zod # pnpm </code></pre><p class="mb-4">Zod also publishes a canary version on every commit. To install the canary:</p><pre tabindex="0"><code class="language-sh" data-prism="true">npm install zod@canary # npm yarn add zod@canary # yarn bun add zod@canary # bun pnpm add zod@canary # pnpm </code></pre><h1 id="from-deno-land-x-deno" class="heading-1" data-heading="true">From <code>deno.land/x</code> (Deno)</h1><p class="mb-4">Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on <a href="#deno-land-x" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">deno.land/x</a>. The latest version can be imported like so:</p><pre tabindex="0"><code class="language-ts" data-prism="true">import { z } from &quot;https://deno.land/x/zod/mod.ts&quot;; </code></pre><p class="mb-4">You can also specify a particular version:</p><pre tabindex="0"><code class="language-ts" data-prism="true">import { z } from &quot;https://deno.land/x/zod@v3.16.1/mod.ts&quot;; </code></pre><blockquote><p class="mb-4">The rest of this README assumes you are using npm and importing directly from the <code>&quot;zod&quot;</code> package.</p></blockquote><h1 id="basic-usage" class="heading-1" data-heading="true">Basic usage</h1><p class="mb-4">Creating a simple string schema</p><pre tabindex="0"><code class="language-ts" data-prism="true">import { z } from &quot;zod&quot;; // creating a schema for strings const mySchema = z.string(); // parsing mySchema.parse(&quot;tuna&quot;); // =&gt; &quot;tuna&quot; mySchema.parse(12); // =&gt; throws ZodError // &quot;safe&quot; parsing (doesn't throw error if validation fails) mySchema.safeParse(&quot;tuna&quot;); // =&gt; { success: true; data: &quot;tuna&quot; } mySchema.safeParse(12); // =&gt; { success: false; error: ZodError } </code></pre><p class="mb-4">Creating an object schema</p><pre tabindex="0"><code class="language-ts" data-prism="true">import { z } from &quot;zod&quot;; const User = z.object({ username: z.string(), }); User.parse({ username: &quot;Ludwig&quot; }); // extract the inferred type type User = z.infer&lt;typeof User&gt;; // { username: string } </code></pre><h1 id="primitives" class="heading-1" data-heading="true">Primitives</h1><pre tabindex="0"><code class="language-ts" data-prism="true">import { z } from &quot;zod&quot;; // primitive values z.string(); z.number(); z.bigint(); z.boolean(); z.date(); z.symbol(); // empty types z.undefined(); z.null(); z.void(); // accepts undefined // catch-all types // allows any value z.any(); z.unknown(); // never type // allows no values z.never(); </code></pre><h1 id="coercion-for-primitives" class="heading-1" data-heading="true">Coercion for primitives</h1><p class="mb-4">Zod now provides a more convenient way to coerce primitive values.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const schema = z.coerce.string(); schema.parse(&quot;tuna&quot;); // =&gt; &quot;tuna&quot; schema.parse(12); // =&gt; &quot;12&quot; </code></pre><p class="mb-4">During the parsing step, the input is passed through the <code>String()</code> function, which is a JavaScript built-in for coercing data into strings.</p><pre tabindex="0"><code class="language-ts" data-prism="true">schema.parse(12); // =&gt; &quot;12&quot; schema.parse(true); // =&gt; &quot;true&quot; schema.parse(undefined); // =&gt; &quot;undefined&quot; schema.parse(null); // =&gt; &quot;null&quot; </code></pre><p class="mb-4">The returned schema is a normal <code>ZodString</code> instance so you can use all string methods.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.coerce.string().email().min(5); </code></pre><p class="mb-4"><strong>How coercion works</strong></p><p class="mb-4">All primitive types support coercion. Zod coerces all inputs using the built-in constructors: <code>String(input)</code>, <code>Number(input)</code>, <code>new Date(input)</code>, etc.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.coerce.string(); // String(input) z.coerce.number(); // Number(input) z.coerce.boolean(); // Boolean(input) z.coerce.bigint(); // BigInt(input) z.coerce.date(); // new Date(input) </code></pre><p class="mb-4"><strong>Note</strong> — Boolean coercion with <code>z.coerce.boolean()</code> may not work how you expect. Any <a href="#truthy" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">truthy</a> value is coerced to <code>true</code>, and any <a href="#falsy" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">falsy</a> value is coerced to <code>false</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const schema = z.coerce.boolean(); // Boolean(input) schema.parse(&quot;tuna&quot;); // =&gt; true schema.parse(&quot;true&quot;); // =&gt; true schema.parse(&quot;false&quot;); // =&gt; true schema.parse(1); // =&gt; true schema.parse([]); // =&gt; true schema.parse(0); // =&gt; false schema.parse(&quot;&quot;); // =&gt; false schema.parse(undefined); // =&gt; false schema.parse(null); // =&gt; false </code></pre><p class="mb-4">For more control over coercion logic, consider using <a href="#z-preprocess" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>z.preprocess</code></a> or <a href="#z-pipe" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>z.pipe()</code></a>.</p><h1 id="literals" class="heading-1" data-heading="true">Literals</h1><p class="mb-4">Literal schemas represent a <a href="#literal-type" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">literal type</a>, like <code>&quot;hello world&quot;</code> or <code>5</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const tuna = z.literal(&quot;tuna&quot;); const twelve = z.literal(12); const twobig = z.literal(2n); // bigint literal const tru = z.literal(true); const terrificSymbol = Symbol(&quot;terrific&quot;); const terrific = z.literal(terrificSymbol); // retrieve literal value tuna.value; // &quot;tuna&quot; </code></pre><blockquote><p class="mb-4">Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.</p></blockquote><h1 id="strings" class="heading-1" data-heading="true">Strings</h1><p class="mb-4">Zod includes a handful of string-specific validations.</p><pre tabindex="0"><code class="language-ts" data-prism="true">// validations z.string().max(5); z.string().min(5); z.string().length(5); z.string().email(); z.string().url(); z.string().emoji(); z.string().jwt(); // validates format, NOT signature z.string().jwt({ alg: &quot;HS256&quot; }); // specify algorithm z.string().uuid(); z.string().nanoid(); z.string().cuid(); z.string().cuid2(); z.string().ulid(); z.string().xid(); z.string().ksuid(); z.string().regex(regex); z.string().includes(string); z.string().startsWith(string); z.string().endsWith(string); z.string().datetime(); // ISO 8601; by default only `Z` timezone allowed z.string().ip(); // defaults to allow both IPv4 and IPv6 // transforms z.string().trim(); // trim whitespace z.string().toLowerCase(); // toLowerCase z.string().toUpperCase(); // toUpperCase // added in Zod 3.23 z.string().date(); // ISO date format (YYYY-MM-DD) z.string().time(); // ISO time format (HH:mm:ss[.SSSSSS]) z.string().duration(); // ISO 8601 duration z.string().base64(); z.string().e164(); // E.164 number format </code></pre><blockquote><p class="mb-4">Check out <a href="#validator-js" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">validator.js</a> for a bunch of other useful string validation functions that can be used in conjunction with <a href="#refinements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Refinements</a>.</p></blockquote><p class="mb-4">You can customize some common error messages when creating a string schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const name = z.string({ required_error: &quot;Name is required&quot;, invalid_type_error: &quot;Name must be a string&quot;, }); </code></pre><p class="mb-4">When using validation methods, you can pass in an additional argument to provide a custom error message.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.string().min(5, { message: &quot;Must be 5 or more characters long&quot; }); z.string().max(5, { message: &quot;Must be 5 or fewer characters long&quot; }); z.string().length(5, { message: &quot;Must be exactly 5 characters long&quot; }); z.string().email({ message: &quot;Invalid email address&quot; }); z.string().url({ message: &quot;Invalid url&quot; }); z.string().emoji({ message: &quot;Contains non-emoji characters&quot; }); z.string().uuid({ message: &quot;Invalid UUID&quot; }); z.string().includes(&quot;tuna&quot;, { message: &quot;Must include tuna&quot; }); z.string().startsWith(&quot;https://&quot;, { message: &quot;Must provide secure URL&quot; }); z.string().endsWith(&quot;.com&quot;, { message: &quot;Only .com domains allowed&quot; }); z.string().datetime({ message: &quot;Invalid datetime string! Must be UTC.&quot; }); z.string().date({ message: &quot;Invalid date string!&quot; }); z.string().time({ message: &quot;Invalid time string!&quot; }); z.string().ip({ message: &quot;Invalid IP address&quot; }); </code></pre><h1 id="datetimes" class="heading-1" data-heading="true">Datetimes</h1><p class="mb-4">As you may have noticed, Zod string includes a few date/time related validations. These validations are regular expression based, so they are not as strict as a full date/time library. However, they are very convenient for validating user input.</p><p class="mb-4">The <code>z.string().datetime()</code> method enforces ISO 8601; default is no timezone offsets and arbitrary sub-second decimal precision.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const datetime = z.string().datetime(); datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // pass datetime.parse(&quot;2020-01-01T00:00:00.123Z&quot;); // pass datetime.parse(&quot;2020-01-01T00:00:00.123456Z&quot;); // pass (arbitrary precision) datetime.parse(&quot;2020-01-01T00:00:00+02:00&quot;); // fail (no offsets allowed) </code></pre><p class="mb-4">Timezone offsets can be allowed by setting the <code>offset</code> option to <code>true</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const datetime = z.string().datetime({ offset: true }); datetime.parse(&quot;2020-01-01T00:00:00+02:00&quot;); // pass datetime.parse(&quot;2020-01-01T00:00:00.123+02:00&quot;); // pass (millis optional) datetime.parse(&quot;2020-01-01T00:00:00.123+0200&quot;); // pass (millis optional) datetime.parse(&quot;2020-01-01T00:00:00.123+02&quot;); // pass (only offset hours) datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // pass (Z still supported) </code></pre><p class="mb-4">You can additionally constrain the allowable <code>precision</code>. By default, arbitrary sub-second precision is supported (but optional).</p><pre tabindex="0"><code class="language-ts" data-prism="true">const datetime = z.string().datetime({ precision: 3 }); datetime.parse(&quot;2020-01-01T00:00:00.123Z&quot;); // pass datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // fail datetime.parse(&quot;2020-01-01T00:00:00.123456Z&quot;); // fail </code></pre><h1 id="dates" class="heading-1" data-heading="true">Dates</h1><blockquote><p class="mb-4">Added in Zod 3.23</p></blockquote><p class="mb-4">The <code>z.string().date()</code> method validates strings in the format <code>YYYY-MM-DD</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const date = z.string().date(); date.parse(&quot;2020-01-01&quot;); // pass date.parse(&quot;2020-1-1&quot;); // fail date.parse(&quot;2020-01-32&quot;); // fail </code></pre><h1 id="times" class="heading-1" data-heading="true">Times</h1><blockquote><p class="mb-4">Added in Zod 3.23</p></blockquote><p class="mb-4">The <code>z.string().time()</code> method validates strings in the format <code>HH:MM:SS[.s+]</code>. The second can include arbitrary decimal precision. It does not allow timezone offsets of any kind.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const time = z.string().time(); time.parse(&quot;00:00:00&quot;); // pass time.parse(&quot;09:52:31&quot;); // pass time.parse(&quot;23:59:59.9999999&quot;); // pass (arbitrary precision) time.parse(&quot;00:00:00.123Z&quot;); // fail (no `Z` allowed) time.parse(&quot;00:00:00.123+02:00&quot;); // fail (no offsets allowed) </code></pre><p class="mb-4">You can set the <code>precision</code> option to constrain the allowable decimal precision.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const time = z.string().time({ precision: 3 }); time.parse(&quot;00:00:00.123&quot;); // pass time.parse(&quot;00:00:00.123456&quot;); // fail time.parse(&quot;00:00:00&quot;); // fail </code></pre><h1 id="ip-addresses" class="heading-1" data-heading="true">IP addresses</h1><p class="mb-4">The <code>z.string().ip()</code> method by default validate IPv4 and IPv6.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const ip = z.string().ip(); ip.parse(&quot;192.168.1.1&quot;); // pass ip.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003&quot;); // pass ip.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1&quot;); // pass ip.parse(&quot;256.1.1.1&quot;); // fail ip.parse(&quot;84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003&quot;); // fail </code></pre><p class="mb-4">You can additionally set the IP <code>version</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const ipv4 = z.string().ip({ version: &quot;v4&quot; }); ipv4.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003&quot;); // fail const ipv6 = z.string().ip({ version: &quot;v6&quot; }); ipv6.parse(&quot;192.168.1.1&quot;); // fail </code></pre><h1 id="json" class="heading-1" data-heading="true">JSON</h1><p class="mb-4">The <code>z.string().json(...)</code> method parses strings as JSON, then <a href="#pipes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">pipes</a> the result to another specified schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Env = z.object({ API_CONFIG: z.string().json( z.object({ host: z.string(), port: z.number().min(1000).max(2000), }) ), SOME_OTHER_VALUE: z.string(), }); const env = Env.parse({ API_CONFIG: '{ &quot;host&quot;: &quot;example.com&quot;, &quot;port&quot;: 1234 }', SOME_OTHER_VALUE: &quot;abc123&quot;, }); env.API_CONFIG.host; // returns parsed value </code></pre><p class="mb-4">If invalid JSON is encountered, the syntax error will be wrapped and put into a parse error:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const env = Env.safeParse({ API_CONFIG: &quot;not valid json!&quot;, SOME_OTHER_VALUE: &quot;abc123&quot;, }); if (!env.success) { console.log(env.error); // ... Unexpected token n in JSON at position 0 ... } </code></pre><p class="mb-4">This is recommended over using <code>z.string().transform(s =&gt; JSON.parse(s))</code>, since that will not catch parse errors, even when using <code>.safeParse</code>.</p><h1 id="e-164-telephone-numbers" class="heading-1" data-heading="true">E.164 telephone numbers</h1><p class="mb-4">The z.string().e164() method can be used to validate international telephone numbers.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const e164Number = z.string().e164(); e164Number.parse(&quot;+1555555&quot;); // pass e164Number.parse(&quot;+155555555555555&quot;); // pass e164Number.parse(&quot;555555555&quot;); // fail e164Number.parse(&quot;+1 1555555&quot;); // fail </code></pre><h1 id="numbers" class="heading-1" data-heading="true">Numbers</h1><p class="mb-4">You can customize certain error messages when creating a number schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const age = z.number({ required_error: &quot;Age is required&quot;, invalid_type_error: &quot;Age must be a number&quot;, }); </code></pre><p class="mb-4">Zod includes a handful of number-specific validations.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.number().gt(5); z.number().gte(5); // alias .min(5) z.number().lt(5); z.number().lte(5); // alias .max(5) z.number().int(); // value must be an integer z.number().positive(); // &gt; 0 z.number().nonnegative(); // &gt;= 0 z.number().negative(); // &lt; 0 z.number().nonpositive(); // &lt;= 0 z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5) z.number().finite(); // value must be finite, not Infinity or -Infinity z.number().safe(); // value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER </code></pre><p class="mb-4">Optionally, you can pass in a second argument to provide a custom error message.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.number().lte(5, { message: &quot;this👏is👏too👏big&quot; }); </code></pre><h1 id="bigints" class="heading-1" data-heading="true">BigInts</h1><p class="mb-4">Zod includes a handful of bigint-specific validations.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.bigint().gt(5n); z.bigint().gte(5n); // alias `.min(5n)` z.bigint().lt(5n); z.bigint().lte(5n); // alias `.max(5n)` z.bigint().positive(); // &gt; 0n z.bigint().nonnegative(); // &gt;= 0n z.bigint().negative(); // &lt; 0n z.bigint().nonpositive(); // &lt;= 0n z.bigint().multipleOf(5n); // Evenly divisible by 5n. </code></pre><h1 id="nans" class="heading-1" data-heading="true">NaNs</h1><p class="mb-4">You can customize certain error messages when creating a nan schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const isNaN = z.nan({ required_error: &quot;isNaN is required&quot;, invalid_type_error: &quot;isNaN must be 'not a number'&quot;, }); </code></pre><h1 id="booleans" class="heading-1" data-heading="true">Booleans</h1><p class="mb-4">You can customize certain error messages when creating a boolean schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const isActive = z.boolean({ required_error: &quot;isActive is required&quot;, invalid_type_error: &quot;isActive must be a boolean&quot;, }); </code></pre><h1 id="dates" class="heading-1" data-heading="true">Dates</h1><p class="mb-4">Use z.date() to validate <code>Date</code> instances.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.date().safeParse(new Date()); // success: true z.date().safeParse(&quot;2022-01-12T00:00:00.000Z&quot;); // success: false </code></pre><p class="mb-4">You can customize certain error messages when creating a date schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myDateSchema = z.date({ required_error: &quot;Please select a date and time&quot;, invalid_type_error: &quot;That's not a date!&quot;, }); </code></pre><p class="mb-4">Zod provides a handful of date-specific validations.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.date().min(new Date(&quot;1900-01-01&quot;), { message: &quot;Too old&quot; }); z.date().max(new Date(), { message: &quot;Too young!&quot; }); </code></pre><p class="mb-4"><strong>Coercion to Date</strong></p><p class="mb-4">Since <a href="#zod-3-20" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">zod 3.20</a>, use <a href="#z-coerce-date" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>z.coerce.date()</code></a> to pass the input through <code>new Date(input)</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const dateSchema = z.coerce.date(); type DateSchema = z.infer&lt;typeof dateSchema&gt;; // type DateSchema = Date /* valid dates */ console.log(dateSchema.safeParse(&quot;2023-01-10T00:00:00.000Z&quot;).success); // true console.log(dateSchema.safeParse(&quot;2023-01-10&quot;).success); // true console.log(dateSchema.safeParse(&quot;1/10/23&quot;).success); // true console.log(dateSchema.safeParse(new Date(&quot;1/10/23&quot;)).success); // true /* invalid dates */ console.log(dateSchema.safeParse(&quot;2023-13-10&quot;).success); // false console.log(dateSchema.safeParse(&quot;0000-00-00&quot;).success); // false </code></pre><p class="mb-4">For older zod versions, use <a href="#z-preprocess" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>z.preprocess</code></a> like <a href="#described-in-this-thread" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">described in this thread</a>.</p><h1 id="files-browser-only" class="heading-1" data-heading="true">Files (Browser only)</h1><p class="mb-4">Use z.file() to validate <code>File</code> instances.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.file().safeParse(new File([&quot;foobar&quot;], &quot;foobar.txt&quot;, { type: &quot;text/plain&quot; })); // success: true z.file().safeParse(&quot;foobar&quot;); // success: false </code></pre><p class="mb-4">You can customize certain error messages when creating a file schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myFileSchema = z.file({ required_error: &quot;Please select a file&quot;, invalid_type_error: &quot;That's not a file!&quot;, }); </code></pre><p class="mb-4">Zod provides a handful of file-specific validations.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.file().min(100, { message: &quot;Too small&quot; }); z.file().max(10_000, { message: &quot;Too large!&quot; }); z.file().accept([&quot;.txt&quot;, &quot;.csv&quot;], { message: &quot;Accepted file types: .txt, .csv&quot;, }); z.file().accept([&quot;text/plain&quot;], { message: &quot;Accepted file type: text/plain&quot;, }); z.file().filename(z.string().min(3), { message: &quot;Filename must be at least 3 characters long&quot;, }); </code></pre><h1 id="zod-enums" class="heading-1" data-heading="true">Zod enums</h1><pre tabindex="0"><code class="language-ts" data-prism="true">const FishEnum = z.enum([&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]); type FishEnum = z.infer&lt;typeof FishEnum&gt;; // 'Salmon' | 'Tuna' | 'Trout' </code></pre><p class="mb-4"><code>z.enum</code> is a Zod-native way to declare a schema with a fixed set of allowable <em>string</em> values. Pass the array of values directly into <code>z.enum()</code>. Alternatively, use <code>as const</code> to define your enum values as a tuple of strings. See the <a href="#const-assertion-docs" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">const assertion docs</a> for details.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const VALUES = [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;] as const; const FishEnum = z.enum(VALUES); </code></pre><p class="mb-4">This is not allowed, since Zod isn't able to infer the exact values of each element.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const fish = [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]; const FishEnum = z.enum(fish); </code></pre><p class="mb-4"><strong><code>.enum</code></strong></p><p class="mb-4">To get autocompletion with a Zod enum, use the <code>.enum</code> property of your schema:</p><pre tabindex="0"><code class="language-ts" data-prism="true">FishEnum.enum.Salmon; // =&gt; autocompletes FishEnum.enum; /* =&gt; { Salmon: &quot;Salmon&quot;, Tuna: &quot;Tuna&quot;, Trout: &quot;Trout&quot;, } */ </code></pre><p class="mb-4">You can also retrieve the list of options as a tuple with the <code>.options</code> property:</p><pre tabindex="0"><code class="language-ts" data-prism="true">FishEnum.options; // [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]; </code></pre><p class="mb-4"><strong><code>.exclude/.extract()</code></strong></p><p class="mb-4">You can create subsets of a Zod enum with the <code>.exclude</code> and <code>.extract</code> methods.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const FishEnum = z.enum([&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]); const SalmonAndTrout = FishEnum.extract([&quot;Salmon&quot;, &quot;Trout&quot;]); const TunaOnly = FishEnum.exclude([&quot;Salmon&quot;, &quot;Trout&quot;]); </code></pre><h1 id="native-enums" class="heading-1" data-heading="true">Native enums</h1><p class="mb-4">Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use <code>z.nativeEnum()</code>.</p><p class="mb-4"><strong>Numeric enums</strong></p><pre tabindex="0"><code class="language-ts" data-prism="true">enum Fruits { Apple, Banana, } const FruitEnum = z.nativeEnum(Fruits); type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // Fruits FruitEnum.parse(Fruits.Apple); // passes FruitEnum.parse(Fruits.Banana); // passes FruitEnum.parse(0); // passes FruitEnum.parse(1); // passes FruitEnum.parse(3); // fails </code></pre><p class="mb-4"><strong>String enums</strong></p><pre tabindex="0"><code class="language-ts" data-prism="true">enum Fruits { Apple = &quot;apple&quot;, Banana = &quot;banana&quot;, Cantaloupe, // you can mix numerical and string enums } const FruitEnum = z.nativeEnum(Fruits); type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // Fruits FruitEnum.parse(Fruits.Apple); // passes FruitEnum.parse(Fruits.Cantaloupe); // passes FruitEnum.parse(&quot;apple&quot;); // passes FruitEnum.parse(&quot;banana&quot;); // passes FruitEnum.parse(0); // passes FruitEnum.parse(&quot;Cantaloupe&quot;); // fails </code></pre><p class="mb-4"><strong>Const enums</strong></p><p class="mb-4">The <code>.nativeEnum()</code> function works for <code>as const</code> objects as well. ⚠️ <code>as const</code> requires TypeScript 3.4+!</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Fruits = { Apple: &quot;apple&quot;, Banana: &quot;banana&quot;, Cantaloupe: 3, } as const; const FruitEnum = z.nativeEnum(Fruits); type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // &quot;apple&quot; | &quot;banana&quot; | 3 FruitEnum.parse(&quot;apple&quot;); // passes FruitEnum.parse(&quot;banana&quot;); // passes FruitEnum.parse(3); // passes FruitEnum.parse(&quot;Cantaloupe&quot;); // fails </code></pre><p class="mb-4">You can access the underlying object with the <code>.enum</code> property:</p><pre tabindex="0"><code class="language-ts" data-prism="true">FruitEnum.enum.Apple; // &quot;apple&quot; </code></pre><h1 id="optionals" class="heading-1" data-heading="true">Optionals</h1><p class="mb-4">You can make any schema optional with <code>z.optional()</code>. This wraps the schema in a <code>ZodOptional</code> instance and returns the result.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const schema = z.optional(z.string()); schema.parse(undefined); // =&gt; returns undefined type A = z.infer&lt;typeof schema&gt;; // string | undefined </code></pre><p class="mb-4">For convenience, you can also call the <code>.optional()</code> method on an existing schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const user = z.object({ username: z.string().optional(), }); type C = z.infer&lt;typeof user&gt;; // { username?: string | undefined }; </code></pre><p class="mb-4">You can extract the wrapped schema from a <code>ZodOptional</code> instance with <code>.unwrap()</code>.</p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="1">const stringSchema = z.string();</button><button class="tab" data-tab="1" data-group="1">stringSchema; // true</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="1"><pre tabindex="0"><code class="language-ts" data-prism="true">const optionalString = stringSchema.optional(); optionalString.unwrap()</code></pre></div><div class="tab-content" data-tab="1" data-group="1"><pre tabindex="0"><code class="language-ts" data-prism="true"></code></pre></div></div></div><h1 id="nullables" class="heading-1" data-heading="true">Nullables</h1><p class="mb-4">Similarly, you can create nullable types with <code>z.nullable()</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const nullableString = z.nullable(z.string()); nullableString.parse(&quot;asdf&quot;); // =&gt; &quot;asdf&quot; nullableString.parse(null); // =&gt; null </code></pre><p class="mb-4">Or use the <code>.nullable()</code> method.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const E = z.string().nullable(); // equivalent to nullableString type E = z.infer&lt;typeof E&gt;; // string | null </code></pre><p class="mb-4">Extract the inner schema with <code>.unwrap()</code>.</p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="2">const stringSchema = z.string();</button><button class="tab" data-tab="1" data-group="2">stringSchema; // true</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="2"><pre tabindex="0"><code class="language-ts" data-prism="true">const nullableString = stringSchema.nullable(); nullableString.unwrap()</code></pre></div><div class="tab-content" data-tab="1" data-group="2"><pre tabindex="0"><code class="language-ts" data-prism="true"></code></pre></div></div></div><h1 id="objects" class="heading-1" data-heading="true">Objects</h1><pre tabindex="0"><code class="language-ts" data-prism="true">// all properties are required by default const Dog = z.object({ name: z.string(), age: z.number(), }); // extract the inferred type like this type Dog = z.infer&lt;typeof Dog&gt;; // equivalent to: type Dog = { name: string; age: number; }; </code></pre><h1 id="shape" class="heading-1" data-heading="true"><code>.shape</code></h1><p class="mb-4">Use <code>.shape</code> to access the schemas for a particular key.</p><pre tabindex="0"><code class="language-ts" data-prism="true">Dog.shape.name; // =&gt; string schema Dog.shape.age; // =&gt; number schema </code></pre><h1 id="keyof" class="heading-1" data-heading="true"><code>.keyof</code></h1><p class="mb-4">Use <code>.keyof</code> to create a <code>ZodEnum</code> schema from the keys of an object schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const keySchema = Dog.keyof(); keySchema; // ZodEnum&lt;[&quot;name&quot;, &quot;age&quot;]&gt; </code></pre><h1 id="extend" class="heading-1" data-heading="true"><code>.extend</code></h1><p class="mb-4">You can add additional fields to an object schema with the <code>.extend</code> method.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const DogWithBreed = Dog.extend({ breed: z.string(), }); </code></pre><p class="mb-4">You can use <code>.extend</code> to overwrite fields! Be careful with this power!</p><h1 id="merge" class="heading-1" data-heading="true"><code>.merge</code></h1><p class="mb-4">Equivalent to <code>A.extend(B.shape)</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const BaseTeacher = z.object({ students: z.array(z.string()) }); const HasID = z.object({ id: z.string() }); const Teacher = BaseTeacher.merge(HasID); type Teacher = z.infer&lt;typeof Teacher&gt;; // =&gt; { students: string[], id: string } </code></pre><blockquote><p class="mb-4">If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "unknownKeys" policy (strip/strict/passthrough) and the catchall schema of B.</p></blockquote><h1 id="pick-omit" class="heading-1" data-heading="true"><code>.pick/.omit</code></h1><p class="mb-4">Inspired by TypeScript's built-in <code>Pick</code> and <code>Omit</code> utility types, all Zod object schemas have <code>.pick</code> and <code>.omit</code> methods that return a modified version. Consider this Recipe schema:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Recipe = z.object({ id: z.string(), name: z.string(), ingredients: z.array(z.string()), }); </code></pre><p class="mb-4">To only keep certain keys, use <code>.pick</code> .</p><pre tabindex="0"><code class="language-ts" data-prism="true">const JustTheName = Recipe.pick({ name: true }); type JustTheName = z.infer&lt;typeof JustTheName&gt;; // =&gt; { name: string } </code></pre><p class="mb-4">To remove certain keys, use <code>.omit</code> .</p><pre tabindex="0"><code class="language-ts" data-prism="true">const NoIDRecipe = Recipe.omit({ id: true }); type NoIDRecipe = z.infer&lt;typeof NoIDRecipe&gt;; // =&gt; { name: string, ingredients: string[] } </code></pre><h1 id="partial" class="heading-1" data-heading="true"><code>.partial</code></h1><p class="mb-4">Inspired by the built-in TypeScript utility type <a href="#partial" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Partial</a>, the <code>.partial</code> method makes all properties optional.</p><p class="mb-4">Starting from this object:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const user = z.object({ email: z.string(), username: z.string(), }); // { email: string; username: string } </code></pre><p class="mb-4">We can create a partial version:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const partialUser = user.partial(); // { email?: string | undefined; username?: string | undefined } </code></pre><p class="mb-4">You can also specify which properties to make optional:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const optionalEmail = user.partial({ email: true, }); /* { email?: string | undefined; username: string } */ </code></pre><h1 id="deeppartial" class="heading-1" data-heading="true"><code>.deepPartial</code></h1><p class="mb-4">The <code>.partial</code> method is shallow — it only applies one level deep. There is also a "deep" version:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const user = z.object({ username: z.string(), location: z.object({ latitude: z.number(), longitude: z.number(), }), strings: z.array(z.object({ value: z.string() })), }); const deepPartialUser = user.deepPartial(); /* { username?: string | undefined, location?: { latitude?: number | undefined; longitude?: number | undefined; } | undefined, strings?: { value?: string}[] } */ </code></pre><blockquote><p class="mb-4">Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.</p></blockquote><h1 id="required" class="heading-1" data-heading="true"><code>.required</code></h1><p class="mb-4">Contrary to the <code>.partial</code> method, the <code>.required</code> method makes all properties required.</p><p class="mb-4">Starting from this object:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const user = z .object({ email: z.string(), username: z.string(), }) .partial(); // { email?: string | undefined; username?: string | undefined } </code></pre><p class="mb-4">We can create a required version:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const requiredUser = user.required(); // { email: string; username: string } </code></pre><p class="mb-4">You can also specify which properties to make required:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const requiredEmail = user.required({ email: true, }); /* { email: string; username?: string | undefined; } */ </code></pre><h1 id="passthrough" class="heading-1" data-heading="true"><code>.passthrough</code></h1><p class="mb-4">By default Zod object schemas strip out unrecognized keys during parsing.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const person = z.object({ name: z.string(), }); person.parse({ name: &quot;bob dylan&quot;, extraKey: 61, }); // =&gt; { name: &quot;bob dylan&quot; } // extraKey has been stripped </code></pre><p class="mb-4">Instead, if you want to pass through unknown keys, use <code>.passthrough()</code> .</p><pre tabindex="0"><code class="language-ts" data-prism="true">person.passthrough().parse({ name: &quot;bob dylan&quot;, extraKey: 61, }); // =&gt; { name: &quot;bob dylan&quot;, extraKey: 61 } </code></pre><h1 id="strict" class="heading-1" data-heading="true"><code>.strict</code></h1><p class="mb-4">By default Zod object schemas strip out unrecognized keys during parsing. You can <em>disallow</em> unknown keys with <code>.strict()</code> . If there are any unknown keys in the input, Zod will throw an error.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const person = z .object({ name: z.string(), }) .strict(); person.parse({ name: &quot;bob dylan&quot;, extraKey: 61, }); // =&gt; throws ZodError </code></pre><h1 id="strip" class="heading-1" data-heading="true"><code>.strip</code></h1><p class="mb-4">You can use the <code>.strip</code> method to reset an object schema to the default behavior (stripping unrecognized keys).</p><h1 id="catchall" class="heading-1" data-heading="true"><code>.catchall</code></h1><p class="mb-4">You can pass a "catchall" schema into an object schema. All unknown keys will be validated against it.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const person = z .object({ name: z.string(), }) .catchall(z.number()); person.parse({ name: &quot;bob dylan&quot;, validExtraKey: 61, // works fine }); person.parse({ name: &quot;bob dylan&quot;, validExtraKey: false, // fails }); // =&gt; throws ZodError </code></pre><p class="mb-4">Using <code>.catchall()</code> obviates <code>.passthrough()</code> , <code>.strip()</code> , or <code>.strict()</code>. All keys are now considered "known".</p><h1 id="arrays" class="heading-1" data-heading="true">Arrays</h1><pre tabindex="0"><code class="language-ts" data-prism="true">const stringArray = z.array(z.string()); // equivalent const stringArray = z.string().array(); </code></pre><p class="mb-4">Be careful with the <code>.array()</code> method. It returns a new <code>ZodArray</code> instance. This means the <em>order</em> in which you call methods matters. For instance:</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.string().optional().array(); // (string | undefined)[] z.string().array().optional(); // string[] | undefined </code></pre><h1 id="element" class="heading-1" data-heading="true"><code>.element</code></h1><p class="mb-4">Use <code>.element</code> to access the schema for an element of the array.</p><pre tabindex="0"><code class="language-ts" data-prism="true">stringArray.element; // =&gt; string schema </code></pre><h1 id="nonempty" class="heading-1" data-heading="true"><code>.nonempty</code></h1><p class="mb-4">If you want to ensure that an array contains at least one element, use <code>.nonempty()</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const nonEmptyStrings = z.string().array().nonempty(); // the inferred type is now // [string, ...string[]] nonEmptyStrings.parse([]); // throws: &quot;Array cannot be empty&quot; nonEmptyStrings.parse([&quot;Ariana Grande&quot;]); // passes </code></pre><p class="mb-4">You can optionally specify a custom error message:</p><pre tabindex="0"><code class="language-ts" data-prism="true">// optional custom error message const nonEmptyStrings = z.string().array().nonempty({ message: &quot;Can't be empty!&quot;, }); </code></pre><h1 id="min-max-length" class="heading-1" data-heading="true"><code>.min/.max/.length</code></h1><pre tabindex="0"><code class="language-ts" data-prism="true">z.string().array().min(5); // must contain 5 or more items z.string().array().max(5); // must contain 5 or fewer items z.string().array().length(5); // must contain 5 items exactly </code></pre><p class="mb-4">Unlike <code>.nonempty()</code> these methods do not change the inferred type.</p><h1 id="unique" class="heading-1" data-heading="true"><code>.unique</code></h1><pre tabindex="0"><code class="language-ts" data-prism="true">// All elements must be unique z.object({ id: z.string() }).array().unique(); // All elements must be unique based on the id property z.object({ id: z.string(), name: z.string() }) .array() .unique({ identifier: (elt) =&gt; elt.id }); </code></pre><h1 id="tuples" class="heading-1" data-heading="true">Tuples</h1><p class="mb-4">Unlike arrays, tuples have a fixed number of elements and each element can have a different type.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const athleteSchema = z.tuple([ z.string(), // name z.number(), // jersey number z.object({ pointsScored: z.number(), }), // statistics ]); type Athlete = z.infer&lt;typeof athleteSchema&gt;; // type Athlete = [string, number, { pointsScored: number }] </code></pre><p class="mb-4">A variadic ("rest") argument can be added with the <code>.rest</code> method.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const variadicTuple = z.tuple([z.string()]).rest(z.number()); const result = variadicTuple.parse([&quot;hello&quot;, 1, 2, 3]); // =&gt; [string, ...number[]]; </code></pre><h1 id="unions" class="heading-1" data-heading="true">Unions</h1><p class="mb-4">Zod includes a built-in <code>z.union</code> method for composing "OR" types.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringOrNumber = z.union([z.string(), z.number()]); stringOrNumber.parse(&quot;foo&quot;); // passes stringOrNumber.parse(14); // passes </code></pre><p class="mb-4">Zod will test the input against each of the "options" in order and return the first value that validates successfully.</p><p class="mb-4">For convenience, you can also use the <a href="#or-method" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.or</code> method</a>:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringOrNumber = z.string().or(z.number()); </code></pre><p class="mb-4"><strong>Optional string validation:</strong></p><p class="mb-4">To validate an optional form input, you can union the desired string validation with an empty string <a href="#literal" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">literal</a>.</p><p class="mb-4">This example validates an input that is optional but needs to contain a <a href="#valid-url" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">valid URL</a>:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const optionalUrl = z.union([z.string().url().nullish(), z.literal(&quot;&quot;)]); console.log(optionalUrl.safeParse(undefined).success); // true console.log(optionalUrl.safeParse(null).success); // true console.log(optionalUrl.safeParse(&quot;&quot;).success); // true console.log(optionalUrl.safeParse(&quot;https://zod.dev&quot;).success); // true console.log(optionalUrl.safeParse(&quot;not a valid url&quot;).success); // false </code></pre><h1 id="discriminated-unions" class="heading-1" data-heading="true">Discriminated unions</h1><p class="mb-4">A discriminated union is a union of object schemas that all share a particular key.</p><pre tabindex="0"><code class="language-ts" data-prism="true">type MyUnion = | { status: &quot;success&quot;; data: string } | { status: &quot;failed&quot;; error: Error }; </code></pre><p class="mb-4">Such unions can be represented with the <code>z.discriminatedUnion</code> method. This enables faster evaluation, because Zod can check the <em>discriminator key</em> (<code>status</code> in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.</p><p class="mb-4">With the basic union method, the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myUnion = z.discriminatedUnion(&quot;status&quot;, [ z.object({ status: z.literal(&quot;success&quot;), data: z.string() }), z.object({ status: z.literal(&quot;failed&quot;), error: z.instanceof(Error) }), ]); myUnion.parse({ status: &quot;success&quot;, data: &quot;yippie ki yay&quot; }); </code></pre><p class="mb-4">You can extract a reference to the array of schemas with the <code>.options</code> property.</p><pre tabindex="0"><code class="language-ts" data-prism="true">myUnion.options; // [ZodObject&lt;...&gt;, ZodObject&lt;...&gt;] </code></pre><p class="mb-4">To merge two or more discriminated unions, use <code>.options</code> with destructuring.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const A = z.discriminatedUnion(&quot;status&quot;, [ /* options */ ]); const B = z.discriminatedUnion(&quot;status&quot;, [ /* options */ ]); const AB = z.discriminatedUnion(&quot;status&quot;, [...A.options, ...B.options]); </code></pre><h1 id="records" class="heading-1" data-heading="true">Records</h1><p class="mb-4">Record schemas are used to validate types such as <code>Record&lt;string, number&gt;</code>. This is particularly useful for storing or caching items by ID.</p><p class="mb-4"><!-- If you want to validate the <em>values</em> of an object against some schema but don't care about the keys, use <code>z.record(valueType)</code>:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const NumberCache = z.record(z.number()); type NumberCache = z.infer&lt;typeof NumberCache&gt;; // =&gt; { [k: string]: number } ``` --&gt; ```ts const User = z.object({ name: z.string() }); const UserStore = z.record(z.string(), User); type UserStore = z.infer&lt;typeof UserStore&gt;; // =&gt; Record&lt;string, { name: string }&gt; </code></pre><p class="mb-4">The schema and inferred type can be used like so:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const userStore: UserStore = {}; userStore[&quot;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&quot;] = { name: &quot;Carlotta&quot;, }; // passes userStore[&quot;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&quot;] = { whatever: &quot;Ice cream sundae&quot;, }; // TypeError </code></pre><p class="mb-4"><strong>A note on numerical keys</strong></p><p class="mb-4">While <code>z.record(keyType, valueType)</code> is able to accept numerical key types and TypeScript's built-in Record type is <code>Record&lt;KeyType, ValueType&gt;</code>, it's hard to represent the TypeScript type <code>Record&lt;number, any&gt;</code> in Zod.</p><p class="mb-4">As it turns out, TypeScript's behavior surrounding <code>[k: number]</code> is a little unintuitive:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const testMap: { [k: number]: string } = { 1: &quot;one&quot;, }; for (const key in testMap) { console.log(`${key}: ${typeof key}`); } // prints: `1: string` </code></pre><p class="mb-4">As you can see, JavaScript automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.</p><h1 id="maps" class="heading-1" data-heading="true">Maps</h1><pre tabindex="0"><code class="language-ts" data-prism="true">const stringNumberMap = z.map(z.string(), z.number()); type StringNumberMap = z.infer&lt;typeof stringNumberMap&gt;; // type StringNumberMap = Map&lt;string, number&gt; </code></pre><h1 id="sets" class="heading-1" data-heading="true">Sets</h1><pre tabindex="0"><code class="language-ts" data-prism="true">const numberSet = z.set(z.number()); type NumberSet = z.infer&lt;typeof numberSet&gt;; // type NumberSet = Set&lt;number&gt; </code></pre><p class="mb-4">Set schemas can be further constrained with the following utility methods.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.set(z.string()).nonempty(); // must contain at least one item z.set(z.string()).min(5); // must contain 5 or more items z.set(z.string()).max(5); // must contain 5 or fewer items z.set(z.string()).size(5); // must contain 5 items exactly </code></pre><h1 id="intersections" class="heading-1" data-heading="true">Intersections</h1><p class="mb-4">Intersections are useful for creating "logical AND" types. This is useful for intersecting two object types.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Person = z.object({ name: z.string(), }); const Employee = z.object({ role: z.string(), }); const EmployedPerson = z.intersection(Person, Employee); // equivalent to: const EmployedPerson = Person.and(Employee); </code></pre><p class="mb-4">Though in many cases, it is recommended to use <code>A.merge(B)</code> to merge two objects. The <code>.merge</code> method returns a new <code>ZodObject</code> instance, whereas <code>A.and(B)</code> returns a less useful <code>ZodIntersection</code> instance that lacks common object methods like <code>pick</code> and <code>omit</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const a = z.union([z.number(), z.string()]); const b = z.union([z.number(), z.boolean()]); const c = z.intersection(a, b); type c = z.infer&lt;typeof c&gt;; // =&gt; number </code></pre><p class="mb-4"><!-- Intersections in Zod are not smart. Whatever data you pass into <code>.parse()</code> gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. --></p><p class="mb-4"><!--</p><pre tabindex="0"><code class="language-text" data-prism="true">const A = z.object({ a: z.string(), }); const B = z.object({ b: z.string(), }); const AB = z.intersection(A, B); type Teacher = z.infer&lt;typeof Teacher&gt;; // { id:string; name:string }; ``` --&gt; ## Recursive types You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a &quot;type hint&quot;. ```ts const baseCategorySchema = z.object({ name: z.string(), }); type Category = z.infer&lt;typeof baseCategorySchema&gt; &amp; { subcategories: Category[]; }; const categorySchema: z.ZodType&lt;Category&gt; = baseCategorySchema.extend({ subcategories: z.lazy(() =&gt; categorySchema.array()), }); categorySchema.parse({ name: &quot;People&quot;, subcategories: [ { name: &quot;Politicians&quot;, subcategories: [ { name: &quot;Presidents&quot;, subcategories: [], }, ], }, ], }); // passes </code></pre><p class="mb-4">Thanks to <a href="#crasite" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">crasite</a> for this example.</p><h1 id="zodtype-with-zodeffects" class="heading-1" data-heading="true">ZodType with ZodEffects</h1><p class="mb-4">When using <code>z.ZodType</code> with <code>z.ZodEffects</code> ( <a href="#refine" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.refine</code></a>, <a href="#transform" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.transform</code></a>, <a href="#preprocess" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>preprocess</code></a>, etc... ), you will need to define the input and output types of the schema. <code>z.ZodType&lt;Output, z.ZodTypeDef, Input&gt;</code></p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="3">const isValidId = (id: string): id is `${string}/${string}` =></button><button class="tab" data-tab="1" data-group="3">2;</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="3"><pre tabindex="0"><code class="language-ts" data-prism="true">id.split(&quot;/&quot;).length</code></pre></div><div class="tab-content" data-tab="1" data-group="3"><pre tabindex="0"><code class="language-ts" data-prism="true">const baseSchema = z.object({ id: z.string().refine(isValidId), }); type Input = z.input&lt;typeof baseSchema&gt; &amp; { children: Input[]; }; type Output = z.output&lt;typeof baseSchema&gt; &amp; { children: Output[]; }; const schema: z.ZodType&lt;Output, z.ZodTypeDef, Input&gt; = baseSchema.extend({ children: z.lazy(() =&gt; schema.array()), });</code></pre></div></div></div><p class="mb-4">Thanks to <a href="#marcus13371337" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">marcus13371337</a> and <a href="#joelbeeldi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">JoelBeeldi</a> for this example.</p><h1 id="json-type" class="heading-1" data-heading="true">JSON type</h1><p class="mb-4">If you want to validate any JSON value, you can use the snippet below.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]); type Literal = z.infer&lt;typeof literalSchema&gt;; type Json = Literal | { [key: string]: Json } | Json[]; const jsonSchema: z.ZodType&lt;Json&gt; = z.lazy(() =&gt; z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)]) ); jsonSchema.parse(data); </code></pre><p class="mb-4">Thanks to <a href="#ggoodman" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">ggoodman</a> for suggesting this.</p><h1 id="cyclical-objects" class="heading-1" data-heading="true">Cyclical objects</h1><p class="mb-4">Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop in some cases.</p><blockquote><p class="mb-4">To detect cyclical objects before they cause problems, consider <a href="#this-approach" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">this approach</a>.</p></blockquote><h1 id="promises" class="heading-1" data-heading="true">Promises</h1><pre tabindex="0"><code class="language-ts" data-prism="true">const numberPromise = z.promise(z.number()); </code></pre><p class="mb-4">"Parsing" works a little differently with promise schemas. Validation happens in two parts:</p><ol><li>Zod synchronously checks that the input is an instance of Promise (i.e. an object with <code>.then</code> and <code>.catch</code> methods.).</li><li>Zod uses <code>.then</code> to attach an additional validation step onto the existing Promise. You'll have to use <code>.catch</code> on the returned Promise to handle validation failures.</li></ol><pre tabindex="0"><code class="language-ts" data-prism="true">numberPromise.parse(&quot;tuna&quot;); // ZodError: Non-Promise type: string numberPromise.parse(Promise.resolve(&quot;tuna&quot;)); // =&gt; Promise&lt;number&gt; const test = async () =&gt; { await numberPromise.parse(Promise.resolve(&quot;tuna&quot;)); // ZodError: Non-number type: string await numberPromise.parse(Promise.resolve(3.14)); // =&gt; 3.14 }; </code></pre><p class="mb-4"><!-- #### Non-native promise implementations</p><p class="mb-4">When "parsing" a promise, Zod checks that the passed value is an object with <code>.then</code> and <code>.catch</code> methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into <code>z.promise(...).parse</code> with no trouble. One gotcha: the return type of the parse function will be a <em>native</em><code>Promise</code> , so if you have downstream logic that uses non-standard Promise methods, this won't work. --></p><h1 id="instanceof" class="heading-1" data-heading="true">Instanceof</h1><p class="mb-4">You can use <code>z.instanceof</code> to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.</p><pre tabindex="0"><code class="language-ts" data-prism="true">class Test { name: string; } const TestSchema = z.instanceof(Test); const blob: any = &quot;whatever&quot;; TestSchema.parse(new Test()); // passes TestSchema.parse(blob); // throws </code></pre><h1 id="functions" class="heading-1" data-heading="true">Functions</h1><p class="mb-4">Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".</p><p class="mb-4">You can create a function schema with <code>z.function(args, returnType)</code> .</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myFunction = z.function(); type myFunction = z.infer&lt;typeof myFunction&gt;; // =&gt; ()=&gt;unknown </code></pre><p class="mb-4">Define inputs and outputs.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myFunction = z .function() .args(z.string(), z.number()) // accepts an arbitrary number of arguments .returns(z.boolean()); type myFunction = z.infer&lt;typeof myFunction&gt;; // =&gt; (arg0: string, arg1: number)=&gt;boolean </code></pre><p class="mb-4"><!--</p><pre tabindex="0"><code class="language-text" data-prism="true">const args = z.tuple([z.string()]); const returnType = z.number(); const myFunction = z.function(args, returnType); type myFunction = z.infer&lt;typeof myFunction&gt;; // =&gt; (arg0: string)=&gt;number ``` --&gt; Function schemas have an `.implement()` method which accepts a function and returns a new function that automatically validates its inputs and outputs. ```ts const trimmedLength = z .function() .args(z.string()) // accepts an arbitrary number of arguments .returns(z.number()) .implement((x) =&gt; { // TypeScript knows x is a string! return x.trim().length; }); trimmedLength(&quot;sandwich&quot;); // =&gt; 8 trimmedLength(&quot; asdf &quot;); // =&gt; 4 </code></pre><p class="mb-4">If you only care about validating inputs, just don't call the <code>.returns()</code> method. The output type will be inferred from the implementation.</p><blockquote><p class="mb-4">You can use the special <code>z.void()</code> option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)</p></blockquote><pre tabindex="0"><code class="language-ts" data-prism="true">const myFunction = z .function() .args(z.string()) .implement((arg) =&gt; { return [arg.length]; }); myFunction; // (arg: string)=&gt;number[] </code></pre><p class="mb-4">Extract the input and output schemas from a function schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">myFunction.parameters(); // =&gt; ZodTuple&lt;[ZodString, ZodNumber]&gt; myFunction.returnType(); // =&gt; ZodBoolean </code></pre><p class="mb-4"><!-- <code>z.function()</code> accepts two arguments:</p><ul><li><code>args: ZodTuple</code> The first argument is a tuple (created with <code>z.tuple([...])</code> and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (<code>z.tuple([])</code>).</li><li><code>returnType: any Zod schema</code> The second argument is the function's return type. This can be any Zod schema. --></li></ul><h1 id="template-literals" class="heading-1" data-heading="true">Template literals</h1><p class="mb-4">TypeScript supports <a href="#template-literal-types" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">template literal types</a>, which are strings that conform to a statically known structure.</p><pre tabindex="0"><code class="language-ts" data-prism="true">type simpleTemplate = `Hello, ${string}!`; type urlTemplate = `${&quot;http&quot; | &quot;https&quot;}://${string}.${`com` | `net`}`; type pxTemplate = `${number}px`; </code></pre><p class="mb-4">These types can be represented in Zod with <code>z.literal.template()</code>. Template literals consist of interleaved <em>literals</em> and <em>schemas</em>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.literal.template([&quot;Hello, &quot;, z.string()]); // infers to `Hello ${string}` </code></pre><p class="mb-4">The literal components can be any string, number, boolean, null, or undefined.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.literal.template([&quot;Hello&quot;, 3.14, true, null, undefined]); // infers to `Hello3.14truenullundefined` </code></pre><p class="mb-4">The schema components can be any literal, primitive, or enum schema.</p><blockquote><p class="mb-4"><strong>Note</strong> — Refinements, transforms, and pipelines are not supported.</p></blockquote><pre tabindex="0"><code class="language-ts" data-prism="true">z.template.literal([ z.string(), z.number(), z.boolean(), z.bigint(), z.any(), z.literal(&quot;foo&quot;), z.null(), z.undefined(), z.enum([&quot;bar&quot;]), ]); </code></pre><p class="mb-4">For "union" types like <code>z.boolean()</code> or <code>z.enum()</code>, the inferred static type will be a union of the possible values.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.literal.template([z.boolean(), z.number()]); // `true${number}` | `false${number}` z.literal.template([&quot;is_&quot;, z.enum([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])]); // `is_red` | `is_green` | `is_blue` </code></pre><h1 id="examples" class="heading-1" data-heading="true">Examples</h1><p class="mb-4">URL:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const url = z.literal.template([ &quot;https://&quot;, z.string(), &quot;.&quot;, z.enum([&quot;com&quot;, &quot;net&quot;]), ]); // infers to `https://${string}.com` | `https://${string}.net`. url.parse(&quot;https://google.com&quot;); // passes url.parse(&quot;https://google.net&quot;); // passes url.parse(&quot;http://google.com&quot;); // throws url.parse(&quot;https://.com&quot;); // throws url.parse(&quot;https://google&quot;); // throws url.parse(&quot;https://google.&quot;); // throws url.parse(&quot;https://google.gov&quot;); // throws </code></pre><p class="mb-4">CSS Measurement:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const measurement = z.literal.template([ z.number().finite(), z.enum([&quot;px&quot;, &quot;em&quot;, &quot;rem&quot;, &quot;vh&quot;, &quot;vw&quot;, &quot;vmin&quot;, &quot;vmax&quot;]), ]); // infers to `${number}` | `${number}px` | `${number}em` | `${number}rem` | `${number}vh` | `${number}vw` | `${number}vmin` | `${number}vmax </code></pre><p class="mb-4">MongoDB connection string:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const connectionString = z.literal.template([ &quot;mongodb://&quot;, z.literal .template([ z.string().regex(/\w+/).describe(&quot;username&quot;), &quot;:&quot;, z.string().regex(/\w+/).describe(&quot;password&quot;), &quot;@&quot;, ]) .optional(), z.string().regex(/\w+/).describe(&quot;host&quot;), &quot;:&quot;, z.number().finite().int().positive().describe(&quot;port&quot;), z.literal .template([ &quot;/&quot;, z.string().regex(/\w+/).optional().describe(&quot;defaultauthdb&quot;), z.literal .template([&quot;?&quot;, z.string().regex(/^\w+=\w+(&amp;\w+=\w+)*$/)]) .optional() .describe(&quot;options&quot;), ]) .optional(), ]); // inferred type: // | `mongodb://${string}:${number}` // | `mongodb://${string}:${string}@${string}:${number}` // | `mongodb://${string}:${number}/${string}` // | `mongodb://${string}:${string}@${string}:${number}/${string}` // | `mongodb://${string}:${number}/${string}?${string}` // | `mongodb://${string}:${string}@${string}:${number}/${string}?${string}`; </code></pre><h1 id="preprocess" class="heading-1" data-heading="true">Preprocess</h1><blockquote><p class="mb-4">Zod now supports primitive coercion without the need for <code>.preprocess()</code>. See the <a href="#coercion-docs" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">coercion docs</a> for more information.</p></blockquote><p class="mb-4">Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the <a href="#transform-docs" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">.transform docs</a>.)</p><p class="mb-4">But sometimes you want to apply some transform to the input <em>before</em> parsing happens. A common use case: type coercion. Zod enables this with the <code>z.preprocess()</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const castToString = z.preprocess((val) =&gt; String(val), z.string()); </code></pre><p class="mb-4">This returns a <code>ZodEffects</code> instance. <code>ZodEffects</code> is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.</p><h1 id="custom-schemas" class="heading-1" data-heading="true">Custom schemas</h1><p class="mb-4">You can create a Zod schema for any TypeScript type by using <code>z.custom()</code>. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.</p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="4">const px = z.custom<`${number}px`>((val) => {</button><button class="tab" data-tab="1" data-group="4">"string" ? /^\d+px$/.test(val) : false;</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="4"><pre tabindex="0"><code class="language-ts" data-prism="true">return typeof val</code></pre></div><div class="tab-content" data-tab="1" data-group="4"><pre tabindex="0"><code class="language-ts" data-prism="true">}); type px = z.infer&lt;typeof px&gt;; // `${number}px` px.parse(&quot;42px&quot;); // &quot;42px&quot; px.parse(&quot;42vw&quot;); // throws;</code></pre></div></div></div><p class="mb-4">If you don't provide a validation function, Zod will allow any value. This can be dangerous!</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.custom&lt;{ arg: string }&gt;(); // performs no validation </code></pre><p class="mb-4">You can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of <a href="#refine" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.refine</code></a>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.custom&lt;...&gt;((val) =&gt; ..., &quot;custom error message&quot;); </code></pre><h1 id="schema-methods" class="heading-1" data-heading="true">Schema methods</h1><p class="mb-4">All Zod schemas contain certain methods.</p><h1 id="parse" class="heading-1" data-heading="true"><code>.parse</code></h1><p class="mb-4"><code>.parse(data: unknown): T</code></p><p class="mb-4">Given any Zod schema, you can call its <code>.parse</code> method to check <code>data</code> is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.</p><blockquote><p class="mb-4">IMPORTANT: The value returned by <code>.parse</code> is a <em>deep clone</em> of the variable you passed in.</p></blockquote><pre tabindex="0"><code class="language-ts" data-prism="true">const stringSchema = z.string(); stringSchema.parse(&quot;fish&quot;); // =&gt; returns &quot;fish&quot; stringSchema.parse(12); // throws error </code></pre><h1 id="parseasync" class="heading-1" data-heading="true"><code>.parseAsync</code></h1><p class="mb-4"><code>.parseAsync(data:unknown): Promise&lt;T&gt;</code></p><p class="mb-4">If you use asynchronous <a href="#refinements" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">refinements</a> or <a href="#transforms" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">transforms</a> (more on those later), you'll need to use <code>.parseAsync</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringSchema = z.string().refine(async (val) =&gt; val.length &lt;= 8); await stringSchema.parseAsync(&quot;hello&quot;); // =&gt; returns &quot;hello&quot; await stringSchema.parseAsync(&quot;hello world&quot;); // =&gt; throws error </code></pre><h1 id="safeparse" class="heading-1" data-heading="true"><code>.safeParse</code></h1><p class="mb-4"><code>.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }</code></p><p class="mb-4">If you don't want Zod to throw errors when validation fails, use <code>.safeParse</code>. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.</p><pre tabindex="0"><code class="language-ts" data-prism="true">stringSchema.safeParse(12); // =&gt; { success: false; error: ZodError } stringSchema.safeParse(&quot;billie&quot;); // =&gt; { success: true; data: 'billie' } </code></pre><p class="mb-4">The result is a <em>discriminated union</em>, so you can handle errors very conveniently:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const result = stringSchema.safeParse(&quot;billie&quot;); if (!result.success) { // handle error then return result.error; } else { // do something result.data; } </code></pre><h1 id="safeparseasync" class="heading-1" data-heading="true"><code>.safeParseAsync</code></h1><blockquote><p class="mb-4">Alias: <code>.spa</code></p></blockquote><p class="mb-4">An asynchronous version of <code>safeParse</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">await stringSchema.safeParseAsync(&quot;billie&quot;); </code></pre><p class="mb-4">For convenience, this has been aliased to <code>.spa</code>:</p><pre tabindex="0"><code class="language-ts" data-prism="true">await stringSchema.spa(&quot;billie&quot;); </code></pre><h1 id="refine" class="heading-1" data-heading="true"><code>.refine</code></h1><p class="mb-4"><code>.refine(validator: (data:T)=&gt;any, params?: RefineParams)</code></p><p class="mb-4">Zod lets you provide custom validation logic via <em>refinements</em>. (For advanced features like creating multiple issues and customizing error codes, see <a href="#superrefine" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>.superRefine</code></a>.)</p><p class="mb-4">Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.</p><p class="mb-4">For example, you can define a custom validation check on <em>any</em> Zod schema with <code>.refine</code> :</p><pre tabindex="0"><code class="language-ts" data-prism="true">const myString = z.string().refine((val) =&gt; val.length &lt;= 255, { message: &quot;String can't be more than 255 characters&quot;, }); </code></pre><blockquote><p class="mb-4">⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.</p></blockquote><h1 id="arguments" class="heading-1" data-heading="true">Arguments</h1><p class="mb-4">As you can see, <code>.refine</code> takes two arguments.</p><ol><li>The first is the validation function. This function takes one input (of type <code>T</code> — the inferred type of the schema) and returns <code>any</code>. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)</li><li>The second argument accepts some options. You can use this to customize certain error-handling behavior:</li></ol><pre tabindex="0"><code class="language-ts" data-prism="true">type RefineParams = { // override error message message?: string; // appended to error path path?: (string | number)[]; // params object you can use to customize message // in error map params?: object; }; </code></pre><p class="mb-4">For advanced cases, the second argument can also be a function that returns <code>RefineParams</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const longString = z.string().refine( (val) =&gt; val.length &gt; 10, (val) =&gt; ({ message: `${val} is not more than 10 characters` }) ); </code></pre><h1 id="customize-error-path" class="heading-1" data-heading="true">Customize error path</h1><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="5">const passwordForm = z</button><button class="tab" data-tab="1" data-group="5">data.confirm, {</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="5"><pre tabindex="0"><code class="language-ts" data-prism="true">.object({ password: z.string(), confirm: z.string(), }) .refine((data) =&gt; data.password</code></pre></div><div class="tab-content" data-tab="1" data-group="5"><pre tabindex="0"><code class="language-ts" data-prism="true">message: &quot;Passwords don't match&quot;, path: [&quot;confirm&quot;], // path of error }); passwordForm.parse({ password: &quot;asdf&quot;, confirm: &quot;qwer&quot; });</code></pre></div></div></div><p class="mb-4">Because you provided a <code>path</code> parameter, the resulting error will be:</p><pre tabindex="0"><code class="language-ts" data-prism="true">ZodError { issues: [{ &quot;code&quot;: &quot;custom&quot;, &quot;path&quot;: [ &quot;confirm&quot; ], &quot;message&quot;: &quot;Passwords don't match&quot; }] } </code></pre><h1 id="asynchronous-refinements" class="heading-1" data-heading="true">Asynchronous refinements</h1><p class="mb-4">Refinements can also be async:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const userId = z.string().refine(async (id) =&gt; { // verify that ID exists in database return true; }); </code></pre><blockquote><p class="mb-4">⚠️ If you use async refinements, you must use the <code>.parseAsync</code> method to parse data! Otherwise Zod will throw an error.</p></blockquote><h1 id="relationship-to-transforms" class="heading-1" data-heading="true">Relationship to transforms</h1><p class="mb-4">Transforms and refinements can be interleaved:</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.string() .transform((val) =&gt; val.length) .refine((val) =&gt; val &gt; 25); </code></pre><p class="mb-4"><!-- Note that the <code>path</code> is set to <code>[&quot;confirm&quot;]</code> , so you can easily display this error underneath the "Confirm password" textbox.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const allForms = z.object({ passwordForm }).parse({ passwordForm: { password: &quot;asdf&quot;, confirm: &quot;qwer&quot;, }, }); </code></pre><p class="mb-4">would result in</p><pre tabindex="0"><code class="language-text" data-prism="true"> ZodError { issues: [{ &quot;code&quot;: &quot;custom&quot;, &quot;path&quot;: [ &quot;passwordForm&quot;, &quot;confirm&quot; ], &quot;message&quot;: &quot;Passwords don't match&quot; }] } ``` --&gt; ### `.superRefine` The `.refine` method is actually syntactic sugar atop a more versatile (and verbose) method called `superRefine`. Here's an example: ```ts const Strings = z.array(z.string()).superRefine((val, ctx) =&gt; { if (val.length &gt; 3) { ctx.addIssue({ code: z.ZodIssueCode.too_big, maximum: 3, type: &quot;array&quot;, inclusive: true, message: &quot;Too many items 😡&quot;, }); } if (val.length !== new Set(val).size) { ctx.addIssue({ code: z.ZodIssueCode.custom, message: `No duplicates allowed.`, }); } }); </code></pre><p class="mb-4">You can add as many issues as you like. If <code>ctx.addIssue</code> is <em>not</em> called during the execution of the function, validation passes.</p><p class="mb-4">Normally refinements always create issues with a <code>ZodIssueCode.custom</code> error code, but with <code>superRefine</code> it's possible to throw issues of any <code>ZodIssueCode</code>. Each issue code is described in detail in the Error Handling guide: <a href="#error-handling-md" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">ERROR_HANDLING.md</a>.</p><h1 id="abort-early" class="heading-1" data-heading="true">Abort early</h1><p class="mb-4">By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to <em>abort early</em> to prevent later refinements from being executed. To achieve this, pass the <code>fatal</code> flag to <code>ctx.addIssue</code> and return <code>z.NEVER</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const schema = z.number().superRefine((val, ctx) =&gt; { if (val &lt; 10) { ctx.addIssue({ code: z.ZodIssueCode.custom, message: &quot;should be &gt;= 10&quot;, fatal: true, }); return z.NEVER; } if (val !== 12) { ctx.addIssue({ code: z.ZodIssueCode.custom, message: &quot;should be twelve&quot;, }); } }); </code></pre><h1 id="type-refinements" class="heading-1" data-heading="true">Type refinements</h1><p class="mb-4">If you provide a <a href="#type-predicate" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">type predicate</a> to <code>.refine()</code> or <code>.superRefine()</code>, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:</p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="6">const schema = z</button><button class="tab" data-tab="1" data-group="6">"bob", "`first` is not `bob`!");</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="6"><pre tabindex="0"><code class="language-ts" data-prism="true">.object({ first: z.string(), second: z.number(), }) .nullable() .superRefine((arg, ctx): arg is { first: string; second: number } =&gt; { if (!arg) { ctx.addIssue({ code: z.ZodIssueCode.custom, // customize your issue message: &quot;object should exist&quot;, }); } return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing }) // here, TS knows that arg is not null .refine((arg) =&gt; arg.first</code></pre></div><div class="tab-content" data-tab="1" data-group="6"><pre tabindex="0"><code class="language-ts" data-prism="true"></code></pre></div></div></div><blockquote><p class="mb-4">⚠️ You <strong>must</strong> use <code>ctx.addIssue()</code> instead of returning a boolean value to indicate whether the validation passes. If <code>ctx.addIssue</code> is <em>not</em> called during the execution of the function, validation passes.</p></blockquote><h1 id="transform" class="heading-1" data-heading="true"><code>.transform</code></h1><p class="mb-4">To transform data after parsing, use the <code>transform</code> method.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringToNumber = z.string().transform((val) =&gt; val.length); stringToNumber.parse(&quot;string&quot;); // =&gt; 6 </code></pre><h1 id="chaining-order" class="heading-1" data-heading="true">Chaining order</h1><p class="mb-4">Note that <code>stringToNumber</code> above is an instance of the <code>ZodEffects</code> subclass. It is NOT an instance of <code>ZodString</code>. If you want to use the built-in methods of <code>ZodString</code> (e.g. <code>.email()</code>) you must apply those methods <em>before</em> any transforms.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const emailToDomain = z .string() .email() .transform((val) =&gt; val.split(&quot;@&quot;)[1]); emailToDomain.parse(&quot;colinhacks@example.com&quot;); // =&gt; example.com </code></pre><h1 id="validating-during-transform" class="heading-1" data-heading="true">Validating during transform</h1><p class="mb-4">The <code>.transform</code> method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining <code>transform</code> and <code>refine</code>.</p><p class="mb-4">As with <code>.superRefine</code>, the transform function receives a <code>ctx</code> object with an <code>addIssue</code> method that can be used to register validation issues.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const numberInString = z.string().transform((val, ctx) =&gt; { const parsed = parseInt(val); if (isNaN(parsed)) { ctx.addIssue({ code: z.ZodIssueCode.custom, message: &quot;Not a number&quot;, }); // This is a special symbol you can use to // return early from the transform function. // It has type `never` so it does not affect the // inferred return type. return z.NEVER; } return parsed; }); </code></pre><h1 id="relationship-to-refinements" class="heading-1" data-heading="true">Relationship to refinements</h1><p class="mb-4">Transforms and refinements can be interleaved. These will be executed in the order they are declared.</p><div class="tab-group"><div class="tab-list"><button class="tab active" data-tab="0" data-group="7">const nameToGreeting = z</button><button class="tab" data-tab="1" data-group="7">-1);</button></div><div class="tab-contents"><div class="tab-content active" data-tab="0" data-group="7"><pre tabindex="0"><code class="language-ts" data-prism="true">.string() .transform((val) =&gt; val.toUpperCase()) .refine((val) =&gt; val.length &gt; 15) .transform((val) =&gt; `Hello ${val}`) .refine((val) =&gt; val.indexOf(&quot;!&quot;)</code></pre></div><div class="tab-content" data-tab="1" data-group="7"><pre tabindex="0"><code class="language-ts" data-prism="true"></code></pre></div></div></div><h1 id="async-transforms" class="heading-1" data-heading="true">Async transforms</h1><p class="mb-4">Transforms can also be async.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const IdToUser = z .string() .uuid() .transform(async (id) =&gt; { return await getUserById(id); }); </code></pre><blockquote><p class="mb-4">⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.</p></blockquote><h1 id="default" class="heading-1" data-heading="true"><code>.default</code></h1><p class="mb-4">You can use transforms to implement the concept of "default values" in Zod.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringWithDefault = z.string().default(&quot;tuna&quot;); stringWithDefault.parse(undefined); // =&gt; &quot;tuna&quot; </code></pre><p class="mb-4">Optionally, you can pass a function into <code>.default</code> that will be re-executed whenever a default value needs to be generated:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const numberWithRandomDefault = z.number().default(Math.random); numberWithRandomDefault.parse(undefined); // =&gt; 0.4413456736055323 numberWithRandomDefault.parse(undefined); // =&gt; 0.1871840107401901 numberWithRandomDefault.parse(undefined); // =&gt; 0.7223408162401552 </code></pre><p class="mb-4">Conceptually, this is how Zod processes default values:</p><ol><li>If the input is <code>undefined</code>, the default value is returned</li><li>Otherwise, the data is parsed using the base schema</li></ol><h1 id="describe" class="heading-1" data-heading="true"><code>.describe</code></h1><p class="mb-4">Use <code>.describe()</code> to add a <code>description</code> property to the resulting schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const documentedString = z .string() .describe(&quot;A useful bit of text, if you know what to do with it.&quot;); documentedString.description; // A useful bit of text… </code></pre><p class="mb-4">This can be useful for documenting a field, for example in a JSON Schema using a library like <a href="#zod-to-json-schema" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-to-json-schema</code></a>).</p><h1 id="catch" class="heading-1" data-heading="true"><code>.catch</code></h1><p class="mb-4">Use <code>.catch()</code> to provide a "catch value" to be returned in the event of a parsing error.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const numberWithCatch = z.number().catch(42); numberWithCatch.parse(5); // =&gt; 5 numberWithCatch.parse(&quot;tuna&quot;); // =&gt; 42 </code></pre><p class="mb-4">Optionally, you can pass a function into <code>.catch</code> that will be re-executed whenever a default value needs to be generated. A <code>ctx</code> object containing the caught error will be passed into this function.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const numberWithRandomCatch = z.number().catch((ctx) =&gt; { ctx.error; // the caught ZodError return Math.random(); }); numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.4413456736055323 numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.1871840107401901 numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.7223408162401552 </code></pre><p class="mb-4">Conceptually, this is how Zod processes "catch values":</p><ol><li>The data is parsed using the base schema</li><li>If the parsing fails, the "catch value" is returned</li></ol><h1 id="optional" class="heading-1" data-heading="true"><code>.optional</code></h1><p class="mb-4">A convenience method that returns an optional version of a schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const optionalString = z.string().optional(); // string | undefined // equivalent to z.optional(z.string()); </code></pre><h1 id="nullable" class="heading-1" data-heading="true"><code>.nullable</code></h1><p class="mb-4">A convenience method that returns a nullable version of a schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const nullableString = z.string().nullable(); // string | null // equivalent to z.nullable(z.string()); </code></pre><h1 id="nullish" class="heading-1" data-heading="true"><code>.nullish</code></h1><p class="mb-4">A convenience method that returns a "nullish" version of a schema. Nullish schemas will accept both <code>undefined</code> and <code>null</code>. Read more about the concept of "nullish" <a href="#in-the-typescript-3-7-release-notes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">in the TypeScript 3.7 release notes</a>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const nullishString = z.string().nullish(); // string | null | undefined // equivalent to z.string().nullable().optional(); </code></pre><h1 id="array" class="heading-1" data-heading="true"><code>.array</code></h1><p class="mb-4">A convenience method that returns an array schema for the given type:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringArray = z.string().array(); // string[] // equivalent to z.array(z.string()); </code></pre><h1 id="promise" class="heading-1" data-heading="true"><code>.promise</code></h1><p class="mb-4">A convenience method for promise types:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringPromise = z.string().promise(); // Promise&lt;string&gt; // equivalent to z.promise(z.string()); </code></pre><h1 id="or" class="heading-1" data-heading="true"><code>.or</code></h1><p class="mb-4">A convenience method for <a href="#union-types" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">union types</a>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringOrNumber = z.string().or(z.number()); // string | number // equivalent to z.union([z.string(), z.number()]); </code></pre><h1 id="and" class="heading-1" data-heading="true"><code>.and</code></h1><p class="mb-4">A convenience method for creating intersection types.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const nameAndAge = z .object({ name: z.string() }) .and(z.object({ age: z.number() })); // { name: string } &amp; { age: number } // equivalent to z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() })); </code></pre><h1 id="brand" class="heading-1" data-heading="true"><code>.brand</code></h1><p class="mb-4"><code>.brand&lt;T&gt;() =&gt; ZodBranded&lt;this, B&gt;</code></p><p class="mb-4">TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.</p><pre tabindex="0"><code class="language-ts" data-prism="true">type Cat = { name: string }; type Dog = { name: string }; const petCat = (cat: Cat) =&gt; {}; const fido: Dog = { name: &quot;fido&quot; }; petCat(fido); // works fine </code></pre><p class="mb-4">In some cases, its can be desirable to simulate <em>nominal typing</em> inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with <em>branded types</em> (AKA <em>opaque types</em>).</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Cat = z.object({ name: z.string() }).brand&lt;&quot;Cat&quot;&gt;(); type Cat = z.infer&lt;typeof Cat&gt;; const petCat = (cat: Cat) =&gt; {}; // this works const simba = Cat.parse({ name: &quot;simba&quot; }); petCat(simba); // this doesn't petCat({ name: &quot;fido&quot; }); </code></pre><p class="mb-4">Under the hood, this works by attaching a "brand" to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const Cat = z.object({ name: z.string() }).brand&lt;&quot;Cat&quot;&gt;(); type Cat = z.infer&lt;typeof Cat&gt;; // {name: string} &amp; {[symbol]: &quot;Cat&quot;} </code></pre><p class="mb-4">Note that branded types do not affect the runtime result of <code>.parse</code>. It is a static-only construct.</p><h1 id="readonly" class="heading-1" data-heading="true"><code>.readonly</code></h1><p class="mb-4"><code>.readonly() =&gt; ZodReadonly&lt;this&gt;</code></p><p class="mb-4">This method returns a <code>ZodReadonly</code> schema instance that parses the input using the base schema, then calls <code>Object.freeze()</code> on the result. The inferred type is also marked as <code>readonly</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const schema = z.object({ name: z.string() }).readonly(); type schema = z.infer&lt;typeof schema&gt;; // Readonly&lt;{name: string}&gt; const result = schema.parse({ name: &quot;fido&quot; }); result.name = &quot;simba&quot;; // error </code></pre><p class="mb-4">The inferred type uses TypeScript's built-in readonly types when relevant.</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.array(z.string()).readonly(); // readonly string[] z.tuple([z.string(), z.number()]).readonly(); // readonly [string, number] z.map(z.string(), z.date()).readonly(); // ReadonlyMap&lt;string, Date&gt; z.set(z.string()).readonly(); // ReadonlySet&lt;string&gt; </code></pre><h1 id="pipe" class="heading-1" data-heading="true"><code>.pipe</code></h1><p class="mb-4">Schemas can be chained into validation "pipelines". It's useful for easily validating the result after a <code>.transform()</code>:</p><pre tabindex="0"><code class="language-ts" data-prism="true">z.string() .transform((val) =&gt; val.length) .pipe(z.number().min(5)); </code></pre><p class="mb-4">The <code>.pipe()</code> method returns a <code>ZodPipeline</code> instance.</p><h1 id="you-can-use-pipe-to-fix-common-issues-with-z-coerce" class="heading-1" data-heading="true">You can use <code>.pipe()</code> to fix common issues with <code>z.coerce</code>.</h1><p class="mb-4">You can constrain the input to types that work well with your chosen coercion. Then use <code>.pipe()</code> to apply the coercion.</p><p class="mb-4">without constrained input:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const toDate = z.coerce.date(); // works intuitively console.log(toDate.safeParse(&quot;2023-01-01&quot;).success); // true // might not be what you want console.log(toDate.safeParse(null).success); // true </code></pre><p class="mb-4">with constrained input:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const datelike = z.union([z.number(), z.string(), z.date()]); const datelikeToDate = datelike.pipe(z.coerce.date()); // still works intuitively console.log(datelikeToDate.safeParse(&quot;2023-01-01&quot;).success); // true // more likely what you want console.log(datelikeToDate.safeParse(null).success); // false </code></pre><p class="mb-4">You can also use this technique to avoid coercions that throw uncaught errors.</p><p class="mb-4">without constrained input:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const toBigInt = z.coerce.bigint(); // works intuitively console.log(toBigInt.safeParse(&quot;42&quot;)); // true // probably not what you want console.log(toBigInt.safeParse(null)); // throws uncaught error </code></pre><p class="mb-4">with constrained input:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const toNumber = z.number().or(z.string()).pipe(z.coerce.number()); const toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint()); // still works intuitively console.log(toBigInt.safeParse(&quot;42&quot;).success); // true // error handled by zod, more likely what you want console.log(toBigInt.safeParse(null).success); // false </code></pre><h1 id="guides-and-concepts" class="heading-1" data-heading="true">Guides and concepts</h1><h1 id="type-inference" class="heading-1" data-heading="true">Type inference</h1><p class="mb-4">You can extract the TypeScript type of any schema with <code>z.infer&lt;typeof mySchema&gt;</code> .</p><pre tabindex="0"><code class="language-ts" data-prism="true">const A = z.string(); type A = z.infer&lt;typeof A&gt;; // string const u: A = 12; // TypeError const u: A = &quot;asdf&quot;; // compiles </code></pre><p class="mb-4"><strong>What about transforms?</strong></p><p class="mb-4">In reality each Zod schema internally tracks <strong>two</strong> types: an input and an output. For most schemas (e.g. <code>z.string()</code>) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance <code>z.string().transform(val =&gt; val.length)</code> has an input of <code>string</code> and an output of <code>number</code>.</p><p class="mb-4">You can separately extract the input and output types like so:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const stringToNumber = z.string().transform((val) =&gt; val.length); // ⚠️ Important: z.infer returns the OUTPUT type! type input = z.input&lt;typeof stringToNumber&gt;; // string type output = z.output&lt;typeof stringToNumber&gt;; // number // equivalent to z.output! type inferred = z.infer&lt;typeof stringToNumber&gt;; // number </code></pre><h1 id="writing-generic-functions" class="heading-1" data-heading="true">Writing generic functions</h1><p class="mb-4">With TypeScript generics, you can write reusable functions that accept Zod schemas as parameters. This enables you to create custom validation logic, schema transformations, and more, while maintaining type safety and inference.</p><p class="mb-4">When attempting to write a function that accepts a Zod schema as an input, it's tempting to try something like this:</p><pre tabindex="0"><code class="language-ts" data-prism="true">function inferSchema&lt;T&gt;(schema: z.ZodType&lt;T&gt;) { return schema; } </code></pre><p class="mb-4">This approach is incorrect, and limits TypeScript's ability to properly infer the argument. No matter what you pass in, the type of <code>schema</code> will be an instance of <code>ZodType</code>.</p><pre tabindex="0"><code class="language-ts" data-prism="true">inferSchema(z.string()); // =&gt; ZodType&lt;string&gt; </code></pre><p class="mb-4">This approach loses type information, namely <em>which subclass</em> the input actually is (in this case, <code>ZodString</code>). That means you can't call any string-specific methods like <code>.min()</code> on the result of <code>inferSchema</code>.</p><p class="mb-4">A better approach is to infer <em>the schema as a whole</em> instead of merely its inferred type.</p><pre tabindex="0"><code class="language-ts" data-prism="true">function inferSchema&lt;T extends z.ZodType&gt;(schema: T) { return schema; } inferSchema(z.string()); // =&gt; ZodString </code></pre><p class="mb-4">The Result is now fully and properly typed, and the type system can infer the specific subclass of the schema.</p><h1 id="inferrence-in-generic-functions" class="heading-1" data-heading="true">Inferrence in generic functions</h1><p class="mb-4">In the general case, any function that accepts a generic Zod schema as an argument should be explicitly typed.</p><pre tabindex="0"><code class="language-ts" data-prism="true">// doesn't work! function parseData&lt;T extends z.ZodTypeAny&gt;(data: unknown, schema: T) { return schema.parse(data); } parseData(&quot;sup&quot;, z.string()); // =&gt; any </code></pre><p class="mb-4">Note that the return type of <code>parseData</code> is <code>any</code> instead of <code>string</code> as you might expect. There are limits to how TypeScript inference works inside generic functions. Generally speaking, you will need to write an explicit output type.</p><pre tabindex="0"><code class="language-ts" data-prism="true">function parseData&lt;T extends z.ZodTypeAny&gt;( data: unknown, schema: T ): z.infer&lt;T&gt; { return schema.parse(data); } parseData(&quot;sup&quot;, z.string()); // =&gt; string </code></pre><h1 id="constraining-allowable-inputs" class="heading-1" data-heading="true">Constraining allowable inputs</h1><p class="mb-4">The <code>ZodType</code> class has three generic parameters.</p><pre tabindex="0"><code class="language-ts" data-prism="true">class ZodType&lt; Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output &gt; { ... } </code></pre><p class="mb-4">By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function:</p><pre tabindex="0"><code class="language-ts" data-prism="true">function makeSchemaOptional&lt;T extends z.ZodType&lt;string&gt;&gt;(schema: T) { return schema.optional(); } makeSchemaOptional(z.string()); // works fine makeSchemaOptional(z.number()); // Error: 'ZodNumber' is not assignable to parameter of type 'ZodType&lt;string, ZodTypeDef, string&gt;' </code></pre><h1 id="error-handling" class="heading-1" data-heading="true">Error handling</h1><p class="mb-4">Zod provides a subclass of Error called <code>ZodError</code>. ZodErrors contain an <code>issues</code> array containing detailed information about the validation problems.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const result = z .object({ name: z.string(), }) .safeParse({ name: 12 }); if (!result.success) { result.error.issues; /* [ { &quot;code&quot;: &quot;invalid_type&quot;, &quot;expected&quot;: &quot;string&quot;, &quot;received&quot;: &quot;number&quot;, &quot;path&quot;: [ &quot;name&quot; ], &quot;message&quot;: &quot;Expected string, received number&quot; } ] */ } </code></pre><blockquote><p class="mb-4">For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: <a href="#error-handling-md" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">ERROR_HANDLING.md</a></p></blockquote><p class="mb-4">Zod's error reporting emphasizes <em>completeness</em> and <em>correctness</em>. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like <a href="#zod-validation-error" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200"><code>zod-validation-error</code></a></p><h1 id="error-formatting" class="heading-1" data-heading="true">Error formatting</h1><p class="mb-4">You can use the <code>.format()</code> method to convert this error into a nested object.</p><pre tabindex="0"><code class="language-ts" data-prism="true">const result = z .object({ name: z.string(), }) .safeParse({ name: 12 }); if (!result.success) { const formatted = result.error.format(); /* { name: { _errors: [ 'Expected string, received number' ] } } */ formatted.name?._errors; // =&gt; [&quot;Expected string, received number&quot;] } </code></pre><h1 id="comparison" class="heading-1" data-heading="true">Comparison</h1><p class="mb-4">There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.</p><p class="mb-4"><!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. --></p><p class="mb-4"><!-- | Feature | <a href="#zod" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Zod</a> | <a href="#joi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Joi</a> | <a href="#yup" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Yup</a> | <a href="#io-ts" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">io-ts</a> | <a href="#runtypes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Runtypes</a> | <a href="#ow" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">ow</a> | <a href="#class-validator" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">class-validator</a> | | ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: | | <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr> | 🟢 | 🔴 | 🟢 | 🟢 | 🟢 | 🟢 | 🟢 | | <abbr title="Yup's inferred types are incorrect in certain cases, see discussion below.">Correct type inference</abbr> | 🟢 | 🔴 | 🔴 | 🟢 | 🟢 | 🟢 | 🟢 |</p><p class="mb-4"><abbr title="number, string, boolean, null, undefined">Primitive Types</abbr><abbr title="Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.">String Validation</abbr><abbr title="Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.">Number Validation</abbr> Dates</p><p class="mb-4">Primitive Literals Object Literals Tuple Literals Objects Arrays Non-empty arrays Unions Optionals Nullable Enums Enum Autocomplete Intersections Object Merging Tuples Recursive Types Function Schemas</p><p class="mb-4"><abbr title="For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr> Immutable instances Type Guards Validity Checking Casting Default Values Rich Errors Branded --></p><p class="mb-4"><!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)</p><ul><li>Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>)</li><li>Missing lazy/recursive types</li><li>Missing promise schemas</li><li>Missing function schemas</li><li>Missing union & intersection schemas</li><li>Missing support for parsing cyclical data (maybe)</li><li>Missing error customization --></li></ul><h1 id="joi" class="heading-1" data-heading="true">Joi</h1><p class="mb-4"><a href="#https-github-com-hapijs-joi" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">https://github.com/hapijs/joi</a></p><p class="mb-4">Doesn't support static type inference 😕</p><h1 id="yup" class="heading-1" data-heading="true">Yup</h1><p class="mb-4"><a href="#https-github-com-jquense-yup" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">https://github.com/jquense/yup</a></p><p class="mb-4">Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.</p><ul><li>Supports casting and transforms</li><li>All object fields are optional by default <!-- - Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>) --></li><li>Missing promise schemas</li><li>Missing function schemas</li><li>Missing union & intersection schemas</li></ul><p class="mb-4"><!-- ¹Yup has a strange interpretation of the word <code>required</code>. Instead of meaning "not undefined", Yup uses it to mean "not empty". So <code>yup.string().required()</code> will not accept an empty string, and <code>yup.array(yup.string()).required()</code> will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated <code>.nonempty()</code> method to indicate this, or you can implement it with a custom refinement. --></p><h1 id="io-ts" class="heading-1" data-heading="true">io-ts</h1><p class="mb-4"><a href="#https-github-com-gcanti-io-ts" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">https://github.com/gcanti/io-ts</a></p><p class="mb-4">io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.</p><p class="mb-4">In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:</p><pre tabindex="0"><code class="language-ts" data-prism="true">import * as t from &quot;io-ts&quot;; const A = t.type({ foo: t.string, }); const B = t.partial({ bar: t.number, }); const C = t.intersection([A, B]); type C = t.TypeOf&lt;typeof C&gt;; // returns { foo: string; bar?: number | undefined } </code></pre><p class="mb-4">You must define the required and optional props in separate object validators, pass the optionals through <code>t.partial</code> (which marks all properties as optional), then combine them with <code>t.intersection</code> .</p><p class="mb-4">Consider the equivalent in Zod:</p><pre tabindex="0"><code class="language-ts" data-prism="true">const C = z.object({ foo: z.string(), bar: z.number().optional(), }); type C = z.infer&lt;typeof C&gt;; // returns { foo: string; bar?: number | undefined } </code></pre><p class="mb-4">This more declarative API makes schema definitions vastly more concise.</p><p class="mb-4"><code>io-ts</code> also requires the use of gcanti's functional programming library <code>fp-ts</code> to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on <code>fp-ts</code> necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the <code>fp-ts</code> nomenclature to use the library.</p><ul><li>Supports codecs with serialization & deserialization transforms</li><li>Supports branded types</li><li>Supports advanced functional programming, higher-kinded types, <code>fp-ts</code> compatibility</li><li>Missing object methods: (pick, omit, partial, deepPartial, merge, extend)</li><li>Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>)</li><li>Missing promise schemas</li><li>Missing function schemas</li></ul><h1 id="runtypes" class="heading-1" data-heading="true">Runtypes</h1><p class="mb-4"><a href="#https-github-com-pelotom-runtypes" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">https://github.com/pelotom/runtypes</a></p><p class="mb-4">Good type inference support.</p><ul><li>Supports "pattern matching": computed properties that distribute over unions</li><li>Missing object methods: (deepPartial, merge)</li><li>Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>)</li><li>Missing promise schemas</li><li>Missing error customization</li></ul><h1 id="ow" class="heading-1" data-heading="true">Ow</h1><p class="mb-4"><a href="#https-github-com-sindresorhus-ow" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">https://github.com/sindresorhus/ow</a></p><p class="mb-4">Ow is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. <code>int32Array</code> , see full list in their README).</p><p class="mb-4">If you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.</p><h1 id="changelog" class="heading-1" data-heading="true">Changelog</h1><p class="mb-4">View the changelog at <a href="#changelog-md" title="undefined" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">CHANGELOG.md</a></p>
        </main>
        <aside class="fixed top-0 right-0 w-72 h-screen overflow-y-auto p-6 border-l border-slate-700/50 bg-slate-900/80 backdrop-blur-sm shadow-xl">
            <nav class="space-y-1">
                
            </nav>
        </aside>
    </div>
    <script src="https://unpkg.com/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://unpkg.com/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="tabs.js"></script>
    <script src="scroll.js"></script>
    <script>
        // Initialize syntax highlighting
        Prism.highlightAll();

        // Re-run highlighting when switching tabs
        document.addEventListener('tabChanged', () => {
            Prism.highlightAll();
        });
    </script>
</body>
</html>
